{"ast":null,"code":"/* @preserve\n * Leaflet 1.4.0, a JS library for interactive maps. http://leafletjs.com\n * (c) 2010-2018 Vladimir Agafonkin, (c) 2010-2011 CloudMade\n */\n!function (t, i) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? i(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], i) : i(t.L = {});\n}(this, function (t) {\n  \"use strict\";\n\n  function i(t) {\n    var i, e, n, o;\n\n    for (e = 1, n = arguments.length; e < n; e++) {\n      o = arguments[e];\n\n      for (i in o) {\n        t[i] = o[i];\n      }\n    }\n\n    return t;\n  }\n\n  function e(t, i) {\n    var e = Array.prototype.slice;\n    if (t.bind) return t.bind.apply(t, e.call(arguments, 1));\n    var n = e.call(arguments, 2);\n    return function () {\n      return t.apply(i, n.length ? n.concat(e.call(arguments)) : arguments);\n    };\n  }\n\n  function n(t) {\n    return t._leaflet_id = t._leaflet_id || ++ei, t._leaflet_id;\n  }\n\n  function o(t, i, e) {\n    var n, o, s, r;\n    return r = function r() {\n      n = !1, o && (s.apply(e, o), o = !1);\n    }, s = function s() {\n      n ? o = arguments : (t.apply(e, arguments), setTimeout(r, i), n = !0);\n    };\n  }\n\n  function s(t, i, e) {\n    var n = i[1],\n        o = i[0],\n        s = n - o;\n    return t === n && e ? t : ((t - o) % s + s) % s + o;\n  }\n\n  function r() {\n    return !1;\n  }\n\n  function a(t, i) {\n    var e = Math.pow(10, void 0 === i ? 6 : i);\n    return Math.round(t * e) / e;\n  }\n\n  function h(t) {\n    return t.trim ? t.trim() : t.replace(/^\\s+|\\s+$/g, \"\");\n  }\n\n  function u(t) {\n    return h(t).split(/\\s+/);\n  }\n\n  function l(t, i) {\n    t.hasOwnProperty(\"options\") || (t.options = t.options ? ii(t.options) : {});\n\n    for (var e in i) {\n      t.options[e] = i[e];\n    }\n\n    return t.options;\n  }\n\n  function c(t, i, e) {\n    var n = [];\n\n    for (var o in t) {\n      n.push(encodeURIComponent(e ? o.toUpperCase() : o) + \"=\" + encodeURIComponent(t[o]));\n    }\n\n    return (i && -1 !== i.indexOf(\"?\") ? \"&\" : \"?\") + n.join(\"&\");\n  }\n\n  function _(t, i) {\n    return t.replace(ni, function (t, e) {\n      var n = i[e];\n      if (void 0 === n) throw new Error(\"No value provided for variable \" + t);\n      return \"function\" == typeof n && (n = n(i)), n;\n    });\n  }\n\n  function d(t, i) {\n    for (var e = 0; e < t.length; e++) {\n      if (t[e] === i) return e;\n    }\n\n    return -1;\n  }\n\n  function p(t) {\n    return window[\"webkit\" + t] || window[\"moz\" + t] || window[\"ms\" + t];\n  }\n\n  function m(t) {\n    var i = +new Date(),\n        e = Math.max(0, 16 - (i - ri));\n    return ri = i + e, window.setTimeout(t, e);\n  }\n\n  function f(t, i, n) {\n    if (!n || ai !== m) return ai.call(window, e(t, i));\n    t.call(i);\n  }\n\n  function g(t) {\n    t && hi.call(window, t);\n  }\n\n  function v() {}\n\n  function y(t) {\n    if (\"undefined\" != typeof L && L && L.Mixin) {\n      t = oi(t) ? t : [t];\n\n      for (var i = 0; i < t.length; i++) {\n        t[i] === L.Mixin.Events && console.warn(\"Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.\", new Error().stack);\n      }\n    }\n  }\n\n  function x(t, i, e) {\n    this.x = e ? Math.round(t) : t, this.y = e ? Math.round(i) : i;\n  }\n\n  function w(t, i, e) {\n    return t instanceof x ? t : oi(t) ? new x(t[0], t[1]) : void 0 === t || null === t ? t : \"object\" == typeof t && \"x\" in t && \"y\" in t ? new x(t.x, t.y) : new x(t, i, e);\n  }\n\n  function P(t, i) {\n    if (t) for (var e = i ? [t, i] : t, n = 0, o = e.length; n < o; n++) {\n      this.extend(e[n]);\n    }\n  }\n\n  function b(t, i) {\n    return !t || t instanceof P ? t : new P(t, i);\n  }\n\n  function T(t, i) {\n    if (t) for (var e = i ? [t, i] : t, n = 0, o = e.length; n < o; n++) {\n      this.extend(e[n]);\n    }\n  }\n\n  function z(t, i) {\n    return t instanceof T ? t : new T(t, i);\n  }\n\n  function M(t, i, e) {\n    if (isNaN(t) || isNaN(i)) throw new Error(\"Invalid LatLng object: (\" + t + \", \" + i + \")\");\n    this.lat = +t, this.lng = +i, void 0 !== e && (this.alt = +e);\n  }\n\n  function C(t, i, e) {\n    return t instanceof M ? t : oi(t) && \"object\" != typeof t[0] ? 3 === t.length ? new M(t[0], t[1], t[2]) : 2 === t.length ? new M(t[0], t[1]) : null : void 0 === t || null === t ? t : \"object\" == typeof t && \"lat\" in t ? new M(t.lat, \"lng\" in t ? t.lng : t.lon, t.alt) : void 0 === i ? null : new M(t, i, e);\n  }\n\n  function S(t, i, e, n) {\n    if (oi(t)) return this._a = t[0], this._b = t[1], this._c = t[2], void (this._d = t[3]);\n    this._a = t, this._b = i, this._c = e, this._d = n;\n  }\n\n  function Z(t, i, e, n) {\n    return new S(t, i, e, n);\n  }\n\n  function E(t) {\n    return document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n  }\n\n  function k(t, i) {\n    var e,\n        n,\n        o,\n        s,\n        r,\n        a,\n        h = \"\";\n\n    for (e = 0, o = t.length; e < o; e++) {\n      for (n = 0, s = (r = t[e]).length; n < s; n++) {\n        a = r[n], h += (n ? \"L\" : \"M\") + a.x + \" \" + a.y;\n      }\n\n      h += i ? Ji ? \"z\" : \"x\" : \"\";\n    }\n\n    return h || \"M0 0\";\n  }\n\n  function B(t) {\n    return navigator.userAgent.toLowerCase().indexOf(t) >= 0;\n  }\n\n  function A(t, i, e, n) {\n    return \"touchstart\" === i ? O(t, e, n) : \"touchmove\" === i ? W(t, e, n) : \"touchend\" === i && H(t, e, n), this;\n  }\n\n  function I(t, i, e) {\n    var n = t[\"_leaflet_\" + i + e];\n    return \"touchstart\" === i ? t.removeEventListener(te, n, !1) : \"touchmove\" === i ? t.removeEventListener(ie, n, !1) : \"touchend\" === i && (t.removeEventListener(ee, n, !1), t.removeEventListener(ne, n, !1)), this;\n  }\n\n  function O(t, i, n) {\n    var o = e(function (t) {\n      if (\"mouse\" !== t.pointerType && t.MSPOINTER_TYPE_MOUSE && t.pointerType !== t.MSPOINTER_TYPE_MOUSE) {\n        if (!(oe.indexOf(t.target.tagName) < 0)) return;\n        Pt(t);\n      }\n\n      j(t, i);\n    });\n    t[\"_leaflet_touchstart\" + n] = o, t.addEventListener(te, o, !1), re || (document.documentElement.addEventListener(te, R, !0), document.documentElement.addEventListener(ie, N, !0), document.documentElement.addEventListener(ee, D, !0), document.documentElement.addEventListener(ne, D, !0), re = !0);\n  }\n\n  function R(t) {\n    se[t.pointerId] = t, ae++;\n  }\n\n  function N(t) {\n    se[t.pointerId] && (se[t.pointerId] = t);\n  }\n\n  function D(t) {\n    delete se[t.pointerId], ae--;\n  }\n\n  function j(t, i) {\n    t.touches = [];\n\n    for (var e in se) {\n      t.touches.push(se[e]);\n    }\n\n    t.changedTouches = [t], i(t);\n  }\n\n  function W(t, i, e) {\n    var n = function n(t) {\n      (t.pointerType !== t.MSPOINTER_TYPE_MOUSE && \"mouse\" !== t.pointerType || 0 !== t.buttons) && j(t, i);\n    };\n\n    t[\"_leaflet_touchmove\" + e] = n, t.addEventListener(ie, n, !1);\n  }\n\n  function H(t, i, e) {\n    var n = function n(t) {\n      j(t, i);\n    };\n\n    t[\"_leaflet_touchend\" + e] = n, t.addEventListener(ee, n, !1), t.addEventListener(ne, n, !1);\n  }\n\n  function F(t, i, e) {\n    function n(t) {\n      var i;\n\n      if (Vi) {\n        if (!bi || \"mouse\" === t.pointerType) return;\n        i = ae;\n      } else i = t.touches.length;\n\n      if (!(i > 1)) {\n        var e = Date.now(),\n            n = e - (s || e);\n        r = t.touches ? t.touches[0] : t, a = n > 0 && n <= h, s = e;\n      }\n    }\n\n    function o(t) {\n      if (a && !r.cancelBubble) {\n        if (Vi) {\n          if (!bi || \"mouse\" === t.pointerType) return;\n          var e,\n              n,\n              o = {};\n\n          for (n in r) {\n            e = r[n], o[n] = e && e.bind ? e.bind(r) : e;\n          }\n\n          r = o;\n        }\n\n        r.type = \"dblclick\", i(r), s = null;\n      }\n    }\n\n    var s,\n        r,\n        a = !1,\n        h = 250;\n    return t[le + he + e] = n, t[le + ue + e] = o, t[le + \"dblclick\" + e] = i, t.addEventListener(he, n, !1), t.addEventListener(ue, o, !1), t.addEventListener(\"dblclick\", i, !1), this;\n  }\n\n  function U(t, i) {\n    var e = t[le + he + i],\n        n = t[le + ue + i],\n        o = t[le + \"dblclick\" + i];\n    return t.removeEventListener(he, e, !1), t.removeEventListener(ue, n, !1), bi || t.removeEventListener(\"dblclick\", o, !1), this;\n  }\n\n  function V(t) {\n    return \"string\" == typeof t ? document.getElementById(t) : t;\n  }\n\n  function q(t, i) {\n    var e = t.style[i] || t.currentStyle && t.currentStyle[i];\n\n    if ((!e || \"auto\" === e) && document.defaultView) {\n      var n = document.defaultView.getComputedStyle(t, null);\n      e = n ? n[i] : null;\n    }\n\n    return \"auto\" === e ? null : e;\n  }\n\n  function G(t, i, e) {\n    var n = document.createElement(t);\n    return n.className = i || \"\", e && e.appendChild(n), n;\n  }\n\n  function K(t) {\n    var i = t.parentNode;\n    i && i.removeChild(t);\n  }\n\n  function Y(t) {\n    for (; t.firstChild;) {\n      t.removeChild(t.firstChild);\n    }\n  }\n\n  function X(t) {\n    var i = t.parentNode;\n    i && i.lastChild !== t && i.appendChild(t);\n  }\n\n  function J(t) {\n    var i = t.parentNode;\n    i && i.firstChild !== t && i.insertBefore(t, i.firstChild);\n  }\n\n  function $(t, i) {\n    if (void 0 !== t.classList) return t.classList.contains(i);\n    var e = et(t);\n    return e.length > 0 && new RegExp(\"(^|\\\\s)\" + i + \"(\\\\s|$)\").test(e);\n  }\n\n  function Q(t, i) {\n    if (void 0 !== t.classList) for (var e = u(i), n = 0, o = e.length; n < o; n++) {\n      t.classList.add(e[n]);\n    } else if (!$(t, i)) {\n      var s = et(t);\n      it(t, (s ? s + \" \" : \"\") + i);\n    }\n  }\n\n  function tt(t, i) {\n    void 0 !== t.classList ? t.classList.remove(i) : it(t, h((\" \" + et(t) + \" \").replace(\" \" + i + \" \", \" \")));\n  }\n\n  function it(t, i) {\n    void 0 === t.className.baseVal ? t.className = i : t.className.baseVal = i;\n  }\n\n  function et(t) {\n    return t.correspondingElement && (t = t.correspondingElement), void 0 === t.className.baseVal ? t.className : t.className.baseVal;\n  }\n\n  function nt(t, i) {\n    \"opacity\" in t.style ? t.style.opacity = i : \"filter\" in t.style && ot(t, i);\n  }\n\n  function ot(t, i) {\n    var e = !1,\n        n = \"DXImageTransform.Microsoft.Alpha\";\n\n    try {\n      e = t.filters.item(n);\n    } catch (t) {\n      if (1 === i) return;\n    }\n\n    i = Math.round(100 * i), e ? (e.Enabled = 100 !== i, e.Opacity = i) : t.style.filter += \" progid:\" + n + \"(opacity=\" + i + \")\";\n  }\n\n  function st(t) {\n    for (var i = document.documentElement.style, e = 0; e < t.length; e++) {\n      if (t[e] in i) return t[e];\n    }\n\n    return !1;\n  }\n\n  function rt(t, i, e) {\n    var n = i || new x(0, 0);\n    t.style[ce] = (Ri ? \"translate(\" + n.x + \"px,\" + n.y + \"px)\" : \"translate3d(\" + n.x + \"px,\" + n.y + \"px,0)\") + (e ? \" scale(\" + e + \")\" : \"\");\n  }\n\n  function at(t, i) {\n    t._leaflet_pos = i, ji ? rt(t, i) : (t.style.left = i.x + \"px\", t.style.top = i.y + \"px\");\n  }\n\n  function ht(t) {\n    return t._leaflet_pos || new x(0, 0);\n  }\n\n  function ut() {\n    mt(window, \"dragstart\", Pt);\n  }\n\n  function lt() {\n    ft(window, \"dragstart\", Pt);\n  }\n\n  function ct(t) {\n    for (; -1 === t.tabIndex;) {\n      t = t.parentNode;\n    }\n\n    t.style && (_t(), me = t, fe = t.style.outline, t.style.outline = \"none\", mt(window, \"keydown\", _t));\n  }\n\n  function _t() {\n    me && (me.style.outline = fe, me = void 0, fe = void 0, ft(window, \"keydown\", _t));\n  }\n\n  function dt(t) {\n    do {\n      t = t.parentNode;\n    } while (!(t.offsetWidth && t.offsetHeight || t === document.body));\n\n    return t;\n  }\n\n  function pt(t) {\n    var i = t.getBoundingClientRect();\n    return {\n      x: i.width / t.offsetWidth || 1,\n      y: i.height / t.offsetHeight || 1,\n      boundingClientRect: i\n    };\n  }\n\n  function mt(t, i, e, n) {\n    if (\"object\" == typeof i) for (var o in i) {\n      gt(t, o, i[o], e);\n    } else for (var s = 0, r = (i = u(i)).length; s < r; s++) {\n      gt(t, i[s], e, n);\n    }\n    return this;\n  }\n\n  function ft(t, i, e, n) {\n    if (\"object\" == typeof i) for (var o in i) {\n      vt(t, o, i[o], e);\n    } else if (i) for (var s = 0, r = (i = u(i)).length; s < r; s++) {\n      vt(t, i[s], e, n);\n    } else {\n      for (var a in t[ye]) {\n        vt(t, a, t[ye][a]);\n      }\n\n      delete t[ye];\n    }\n    return this;\n  }\n\n  function gt(t, i, e, o) {\n    var s = i + n(e) + (o ? \"_\" + n(o) : \"\");\n    if (t[ye] && t[ye][s]) return this;\n\n    var r = function r(i) {\n      return e.call(o || t, i || window.event);\n    },\n        a = r;\n\n    Vi && 0 === i.indexOf(\"touch\") ? A(t, i, r, s) : !qi || \"dblclick\" !== i || !F || Vi && Ei ? \"addEventListener\" in t ? \"mousewheel\" === i ? t.addEventListener(\"onwheel\" in t ? \"wheel\" : \"mousewheel\", r, !1) : \"mouseenter\" === i || \"mouseleave\" === i ? (r = function r(i) {\n      i = i || window.event, Ct(t, i) && a(i);\n    }, t.addEventListener(\"mouseenter\" === i ? \"mouseover\" : \"mouseout\", r, !1)) : (\"click\" === i && zi && (r = function r(t) {\n      St(t, a);\n    }), t.addEventListener(i, r, !1)) : \"attachEvent\" in t && t.attachEvent(\"on\" + i, r) : F(t, r, s), t[ye] = t[ye] || {}, t[ye][s] = r;\n  }\n\n  function vt(t, i, e, o) {\n    var s = i + n(e) + (o ? \"_\" + n(o) : \"\"),\n        r = t[ye] && t[ye][s];\n    if (!r) return this;\n    Vi && 0 === i.indexOf(\"touch\") ? I(t, i, s) : !qi || \"dblclick\" !== i || !U || Vi && Ei ? \"removeEventListener\" in t ? \"mousewheel\" === i ? t.removeEventListener(\"onwheel\" in t ? \"wheel\" : \"mousewheel\", r, !1) : t.removeEventListener(\"mouseenter\" === i ? \"mouseover\" : \"mouseleave\" === i ? \"mouseout\" : i, r, !1) : \"detachEvent\" in t && t.detachEvent(\"on\" + i, r) : U(t, s), t[ye][s] = null;\n  }\n\n  function yt(t) {\n    return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, Mt(t), this;\n  }\n\n  function xt(t) {\n    return gt(t, \"mousewheel\", yt), this;\n  }\n\n  function wt(t) {\n    return mt(t, \"mousedown touchstart dblclick\", yt), gt(t, \"click\", zt), this;\n  }\n\n  function Pt(t) {\n    return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this;\n  }\n\n  function Lt(t) {\n    return Pt(t), yt(t), this;\n  }\n\n  function bt(t, i) {\n    if (!i) return new x(t.clientX, t.clientY);\n    var e = pt(i),\n        n = e.boundingClientRect;\n    return new x((t.clientX - n.left) / e.x - i.clientLeft, (t.clientY - n.top) / e.y - i.clientTop);\n  }\n\n  function Tt(t) {\n    return bi ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / xe : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0;\n  }\n\n  function zt(t) {\n    we[t.type] = !0;\n  }\n\n  function Mt(t) {\n    var i = we[t.type];\n    return we[t.type] = !1, i;\n  }\n\n  function Ct(t, i) {\n    var e = i.relatedTarget;\n    if (!e) return !0;\n\n    try {\n      for (; e && e !== t;) {\n        e = e.parentNode;\n      }\n    } catch (t) {\n      return !1;\n    }\n\n    return e !== t;\n  }\n\n  function St(t, i) {\n    var e = t.timeStamp || t.originalEvent && t.originalEvent.timeStamp,\n        n = ge && e - ge;\n    n && n > 100 && n < 500 || t.target._simulatedClick && !t._simulated ? Lt(t) : (ge = e, i(t));\n  }\n\n  function Zt(t, i) {\n    if (!i || !t.length) return t.slice();\n    var e = i * i;\n    return t = At(t, e), t = kt(t, e);\n  }\n\n  function Et(t, i, e) {\n    return Math.sqrt(Dt(t, i, e, !0));\n  }\n\n  function kt(t, i) {\n    var e = t.length,\n        n = new (typeof Uint8Array != void 0 + \"\" ? Uint8Array : Array)(e);\n    n[0] = n[e - 1] = 1, Bt(t, n, i, 0, e - 1);\n    var o,\n        s = [];\n\n    for (o = 0; o < e; o++) {\n      n[o] && s.push(t[o]);\n    }\n\n    return s;\n  }\n\n  function Bt(t, i, e, n, o) {\n    var s,\n        r,\n        a,\n        h = 0;\n\n    for (r = n + 1; r <= o - 1; r++) {\n      (a = Dt(t[r], t[n], t[o], !0)) > h && (s = r, h = a);\n    }\n\n    h > e && (i[s] = 1, Bt(t, i, e, n, s), Bt(t, i, e, s, o));\n  }\n\n  function At(t, i) {\n    for (var e = [t[0]], n = 1, o = 0, s = t.length; n < s; n++) {\n      Nt(t[n], t[o]) > i && (e.push(t[n]), o = n);\n    }\n\n    return o < s - 1 && e.push(t[s - 1]), e;\n  }\n\n  function It(t, i, e, n, o) {\n    var s,\n        r,\n        a,\n        h = n ? ke : Rt(t, e),\n        u = Rt(i, e);\n\n    for (ke = u;;) {\n      if (!(h | u)) return [t, i];\n      if (h & u) return !1;\n      a = Rt(r = Ot(t, i, s = h || u, e, o), e), s === h ? (t = r, h = a) : (i = r, u = a);\n    }\n  }\n\n  function Ot(t, i, e, n, o) {\n    var s,\n        r,\n        a = i.x - t.x,\n        h = i.y - t.y,\n        u = n.min,\n        l = n.max;\n    return 8 & e ? (s = t.x + a * (l.y - t.y) / h, r = l.y) : 4 & e ? (s = t.x + a * (u.y - t.y) / h, r = u.y) : 2 & e ? (s = l.x, r = t.y + h * (l.x - t.x) / a) : 1 & e && (s = u.x, r = t.y + h * (u.x - t.x) / a), new x(s, r, o);\n  }\n\n  function Rt(t, i) {\n    var e = 0;\n    return t.x < i.min.x ? e |= 1 : t.x > i.max.x && (e |= 2), t.y < i.min.y ? e |= 4 : t.y > i.max.y && (e |= 8), e;\n  }\n\n  function Nt(t, i) {\n    var e = i.x - t.x,\n        n = i.y - t.y;\n    return e * e + n * n;\n  }\n\n  function Dt(t, i, e, n) {\n    var o,\n        s = i.x,\n        r = i.y,\n        a = e.x - s,\n        h = e.y - r,\n        u = a * a + h * h;\n    return u > 0 && ((o = ((t.x - s) * a + (t.y - r) * h) / u) > 1 ? (s = e.x, r = e.y) : o > 0 && (s += a * o, r += h * o)), a = t.x - s, h = t.y - r, n ? a * a + h * h : new x(s, r);\n  }\n\n  function jt(t) {\n    return !oi(t[0]) || \"object\" != typeof t[0][0] && void 0 !== t[0][0];\n  }\n\n  function Wt(t) {\n    return console.warn(\"Deprecated use of _flat, please use L.LineUtil.isFlat instead.\"), jt(t);\n  }\n\n  function Ht(t, i, e) {\n    var n,\n        o,\n        s,\n        r,\n        a,\n        h,\n        u,\n        l,\n        c,\n        _ = [1, 4, 2, 8];\n\n    for (o = 0, u = t.length; o < u; o++) {\n      t[o]._code = Rt(t[o], i);\n    }\n\n    for (r = 0; r < 4; r++) {\n      for (l = _[r], n = [], o = 0, s = (u = t.length) - 1; o < u; s = o++) {\n        a = t[o], h = t[s], a._code & l ? h._code & l || ((c = Ot(h, a, l, i, e))._code = Rt(c, i), n.push(c)) : (h._code & l && ((c = Ot(h, a, l, i, e))._code = Rt(c, i), n.push(c)), n.push(a));\n      }\n\n      t = n;\n    }\n\n    return t;\n  }\n\n  function Ft(t, i) {\n    var e,\n        n,\n        o,\n        s,\n        r = \"Feature\" === t.type ? t.geometry : t,\n        a = r ? r.coordinates : null,\n        h = [],\n        u = i && i.pointToLayer,\n        l = i && i.coordsToLatLng || Ut;\n    if (!a && !r) return null;\n\n    switch (r.type) {\n      case \"Point\":\n        return e = l(a), u ? u(t, e) : new $e(e);\n\n      case \"MultiPoint\":\n        for (o = 0, s = a.length; o < s; o++) {\n          e = l(a[o]), h.push(u ? u(t, e) : new $e(e));\n        }\n\n        return new Ke(h);\n\n      case \"LineString\":\n      case \"MultiLineString\":\n        return n = Vt(a, \"LineString\" === r.type ? 0 : 1, l), new nn(n, i);\n\n      case \"Polygon\":\n      case \"MultiPolygon\":\n        return n = Vt(a, \"Polygon\" === r.type ? 1 : 2, l), new on(n, i);\n\n      case \"GeometryCollection\":\n        for (o = 0, s = r.geometries.length; o < s; o++) {\n          var c = Ft({\n            geometry: r.geometries[o],\n            type: \"Feature\",\n            properties: t.properties\n          }, i);\n          c && h.push(c);\n        }\n\n        return new Ke(h);\n\n      default:\n        throw new Error(\"Invalid GeoJSON object.\");\n    }\n  }\n\n  function Ut(t) {\n    return new M(t[1], t[0], t[2]);\n  }\n\n  function Vt(t, i, e) {\n    for (var n, o = [], s = 0, r = t.length; s < r; s++) {\n      n = i ? Vt(t[s], i - 1, e) : (e || Ut)(t[s]), o.push(n);\n    }\n\n    return o;\n  }\n\n  function qt(t, i) {\n    return i = \"number\" == typeof i ? i : 6, void 0 !== t.alt ? [a(t.lng, i), a(t.lat, i), a(t.alt, i)] : [a(t.lng, i), a(t.lat, i)];\n  }\n\n  function Gt(t, i, e, n) {\n    for (var o = [], s = 0, r = t.length; s < r; s++) {\n      o.push(i ? Gt(t[s], i - 1, e, n) : qt(t[s], n));\n    }\n\n    return !i && e && o.push(o[0]), o;\n  }\n\n  function Kt(t, e) {\n    return t.feature ? i({}, t.feature, {\n      geometry: e\n    }) : Yt(e);\n  }\n\n  function Yt(t) {\n    return \"Feature\" === t.type || \"FeatureCollection\" === t.type ? t : {\n      type: \"Feature\",\n      properties: {},\n      geometry: t\n    };\n  }\n\n  function Xt(t, i) {\n    return new sn(t, i);\n  }\n\n  function Jt(t, i) {\n    return new mn(t, i);\n  }\n\n  function $t(t) {\n    return Xi ? new vn(t) : null;\n  }\n\n  function Qt(t) {\n    return Ji || $i ? new Pn(t) : null;\n  }\n\n  var ti = Object.freeze;\n\n  Object.freeze = function (t) {\n    return t;\n  };\n\n  var ii = Object.create || function () {\n    function t() {}\n\n    return function (i) {\n      return t.prototype = i, new t();\n    };\n  }(),\n      ei = 0,\n      ni = /\\{ *([\\w_-]+) *\\}/g,\n      oi = Array.isArray || function (t) {\n    return \"[object Array]\" === Object.prototype.toString.call(t);\n  },\n      si = \"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=\",\n      ri = 0,\n      ai = window.requestAnimationFrame || p(\"RequestAnimationFrame\") || m,\n      hi = window.cancelAnimationFrame || p(\"CancelAnimationFrame\") || p(\"CancelRequestAnimationFrame\") || function (t) {\n    window.clearTimeout(t);\n  },\n      ui = (Object.freeze || Object)({\n    freeze: ti,\n    extend: i,\n    create: ii,\n    bind: e,\n    lastId: ei,\n    stamp: n,\n    throttle: o,\n    wrapNum: s,\n    falseFn: r,\n    formatNum: a,\n    trim: h,\n    splitWords: u,\n    setOptions: l,\n    getParamString: c,\n    template: _,\n    isArray: oi,\n    indexOf: d,\n    emptyImageUrl: si,\n    requestFn: ai,\n    cancelFn: hi,\n    requestAnimFrame: f,\n    cancelAnimFrame: g\n  });\n\n  v.extend = function (t) {\n    var e = function e() {\n      this.initialize && this.initialize.apply(this, arguments), this.callInitHooks();\n    },\n        n = e.__super__ = this.prototype,\n        o = ii(n);\n\n    o.constructor = e, e.prototype = o;\n\n    for (var s in this) {\n      this.hasOwnProperty(s) && \"prototype\" !== s && \"__super__\" !== s && (e[s] = this[s]);\n    }\n\n    return t.statics && (i(e, t.statics), delete t.statics), t.includes && (y(t.includes), i.apply(null, [o].concat(t.includes)), delete t.includes), o.options && (t.options = i(ii(o.options), t.options)), i(o, t), o._initHooks = [], o.callInitHooks = function () {\n      if (!this._initHooksCalled) {\n        n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0;\n\n        for (var t = 0, i = o._initHooks.length; t < i; t++) {\n          o._initHooks[t].call(this);\n        }\n      }\n    }, e;\n  }, v.include = function (t) {\n    return i(this.prototype, t), this;\n  }, v.mergeOptions = function (t) {\n    return i(this.prototype.options, t), this;\n  }, v.addInitHook = function (t) {\n    var i = Array.prototype.slice.call(arguments, 1),\n        e = \"function\" == typeof t ? t : function () {\n      this[t].apply(this, i);\n    };\n    return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(e), this;\n  };\n  var li = {\n    on: function on(t, i, e) {\n      if (\"object\" == typeof t) for (var n in t) {\n        this._on(n, t[n], i);\n      } else for (var o = 0, s = (t = u(t)).length; o < s; o++) {\n        this._on(t[o], i, e);\n      }\n      return this;\n    },\n    off: function off(t, i, e) {\n      if (t) {\n        if (\"object\" == typeof t) for (var n in t) {\n          this._off(n, t[n], i);\n        } else for (var o = 0, s = (t = u(t)).length; o < s; o++) {\n          this._off(t[o], i, e);\n        }\n      } else delete this._events;\n      return this;\n    },\n    _on: function _on(t, i, e) {\n      this._events = this._events || {};\n      var n = this._events[t];\n      n || (n = [], this._events[t] = n), e === this && (e = void 0);\n\n      for (var o = {\n        fn: i,\n        ctx: e\n      }, s = n, r = 0, a = s.length; r < a; r++) {\n        if (s[r].fn === i && s[r].ctx === e) return;\n      }\n\n      s.push(o);\n    },\n    _off: function _off(t, i, e) {\n      var n, o, s;\n      if (this._events && (n = this._events[t])) if (i) {\n        if (e === this && (e = void 0), n) for (o = 0, s = n.length; o < s; o++) {\n          var a = n[o];\n          if (a.ctx === e && a.fn === i) return a.fn = r, this._firingCount && (this._events[t] = n = n.slice()), void n.splice(o, 1);\n        }\n      } else {\n        for (o = 0, s = n.length; o < s; o++) {\n          n[o].fn = r;\n        }\n\n        delete this._events[t];\n      }\n    },\n    fire: function fire(t, e, n) {\n      if (!this.listens(t, n)) return this;\n      var o = i({}, e, {\n        type: t,\n        target: this,\n        sourceTarget: e && e.sourceTarget || this\n      });\n\n      if (this._events) {\n        var s = this._events[t];\n\n        if (s) {\n          this._firingCount = this._firingCount + 1 || 1;\n\n          for (var r = 0, a = s.length; r < a; r++) {\n            var h = s[r];\n            h.fn.call(h.ctx || this, o);\n          }\n\n          this._firingCount--;\n        }\n      }\n\n      return n && this._propagateEvent(o), this;\n    },\n    listens: function listens(t, i) {\n      var e = this._events && this._events[t];\n      if (e && e.length) return !0;\n      if (i) for (var n in this._eventParents) {\n        if (this._eventParents[n].listens(t, i)) return !0;\n      }\n      return !1;\n    },\n    once: function once(t, i, n) {\n      if (\"object\" == typeof t) {\n        for (var o in t) {\n          this.once(o, t[o], i);\n        }\n\n        return this;\n      }\n\n      var s = e(function () {\n        this.off(t, i, n).off(t, s, n);\n      }, this);\n      return this.on(t, i, n).on(t, s, n);\n    },\n    addEventParent: function addEventParent(t) {\n      return this._eventParents = this._eventParents || {}, this._eventParents[n(t)] = t, this;\n    },\n    removeEventParent: function removeEventParent(t) {\n      return this._eventParents && delete this._eventParents[n(t)], this;\n    },\n    _propagateEvent: function _propagateEvent(t) {\n      for (var e in this._eventParents) {\n        this._eventParents[e].fire(t.type, i({\n          layer: t.target,\n          propagatedFrom: t.target\n        }, t), !0);\n      }\n    }\n  };\n  li.addEventListener = li.on, li.removeEventListener = li.clearAllEventListeners = li.off, li.addOneTimeEventListener = li.once, li.fireEvent = li.fire, li.hasEventListeners = li.listens;\n\n  var ci = v.extend(li),\n      _i = Math.trunc || function (t) {\n    return t > 0 ? Math.floor(t) : Math.ceil(t);\n  };\n\n  x.prototype = {\n    clone: function clone() {\n      return new x(this.x, this.y);\n    },\n    add: function add(t) {\n      return this.clone()._add(w(t));\n    },\n    _add: function _add(t) {\n      return this.x += t.x, this.y += t.y, this;\n    },\n    subtract: function subtract(t) {\n      return this.clone()._subtract(w(t));\n    },\n    _subtract: function _subtract(t) {\n      return this.x -= t.x, this.y -= t.y, this;\n    },\n    divideBy: function divideBy(t) {\n      return this.clone()._divideBy(t);\n    },\n    _divideBy: function _divideBy(t) {\n      return this.x /= t, this.y /= t, this;\n    },\n    multiplyBy: function multiplyBy(t) {\n      return this.clone()._multiplyBy(t);\n    },\n    _multiplyBy: function _multiplyBy(t) {\n      return this.x *= t, this.y *= t, this;\n    },\n    scaleBy: function scaleBy(t) {\n      return new x(this.x * t.x, this.y * t.y);\n    },\n    unscaleBy: function unscaleBy(t) {\n      return new x(this.x / t.x, this.y / t.y);\n    },\n    round: function round() {\n      return this.clone()._round();\n    },\n    _round: function _round() {\n      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;\n    },\n    floor: function floor() {\n      return this.clone()._floor();\n    },\n    _floor: function _floor() {\n      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;\n    },\n    ceil: function ceil() {\n      return this.clone()._ceil();\n    },\n    _ceil: function _ceil() {\n      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;\n    },\n    trunc: function trunc() {\n      return this.clone()._trunc();\n    },\n    _trunc: function _trunc() {\n      return this.x = _i(this.x), this.y = _i(this.y), this;\n    },\n    distanceTo: function distanceTo(t) {\n      var i = (t = w(t)).x - this.x,\n          e = t.y - this.y;\n      return Math.sqrt(i * i + e * e);\n    },\n    equals: function equals(t) {\n      return (t = w(t)).x === this.x && t.y === this.y;\n    },\n    contains: function contains(t) {\n      return t = w(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y);\n    },\n    toString: function toString() {\n      return \"Point(\" + a(this.x) + \", \" + a(this.y) + \")\";\n    }\n  }, P.prototype = {\n    extend: function extend(t) {\n      return t = w(t), this.min || this.max ? (this.min.x = Math.min(t.x, this.min.x), this.max.x = Math.max(t.x, this.max.x), this.min.y = Math.min(t.y, this.min.y), this.max.y = Math.max(t.y, this.max.y)) : (this.min = t.clone(), this.max = t.clone()), this;\n    },\n    getCenter: function getCenter(t) {\n      return new x((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t);\n    },\n    getBottomLeft: function getBottomLeft() {\n      return new x(this.min.x, this.max.y);\n    },\n    getTopRight: function getTopRight() {\n      return new x(this.max.x, this.min.y);\n    },\n    getTopLeft: function getTopLeft() {\n      return this.min;\n    },\n    getBottomRight: function getBottomRight() {\n      return this.max;\n    },\n    getSize: function getSize() {\n      return this.max.subtract(this.min);\n    },\n    contains: function contains(t) {\n      var i, e;\n      return (t = \"number\" == typeof t[0] || t instanceof x ? w(t) : b(t)) instanceof P ? (i = t.min, e = t.max) : i = e = t, i.x >= this.min.x && e.x <= this.max.x && i.y >= this.min.y && e.y <= this.max.y;\n    },\n    intersects: function intersects(t) {\n      t = b(t);\n      var i = this.min,\n          e = this.max,\n          n = t.min,\n          o = t.max,\n          s = o.x >= i.x && n.x <= e.x,\n          r = o.y >= i.y && n.y <= e.y;\n      return s && r;\n    },\n    overlaps: function overlaps(t) {\n      t = b(t);\n      var i = this.min,\n          e = this.max,\n          n = t.min,\n          o = t.max,\n          s = o.x > i.x && n.x < e.x,\n          r = o.y > i.y && n.y < e.y;\n      return s && r;\n    },\n    isValid: function isValid() {\n      return !(!this.min || !this.max);\n    }\n  }, T.prototype = {\n    extend: function extend(t) {\n      var i,\n          e,\n          n = this._southWest,\n          o = this._northEast;\n      if (t instanceof M) i = t, e = t;else {\n        if (!(t instanceof T)) return t ? this.extend(C(t) || z(t)) : this;\n        if (i = t._southWest, e = t._northEast, !i || !e) return this;\n      }\n      return n || o ? (n.lat = Math.min(i.lat, n.lat), n.lng = Math.min(i.lng, n.lng), o.lat = Math.max(e.lat, o.lat), o.lng = Math.max(e.lng, o.lng)) : (this._southWest = new M(i.lat, i.lng), this._northEast = new M(e.lat, e.lng)), this;\n    },\n    pad: function pad(t) {\n      var i = this._southWest,\n          e = this._northEast,\n          n = Math.abs(i.lat - e.lat) * t,\n          o = Math.abs(i.lng - e.lng) * t;\n      return new T(new M(i.lat - n, i.lng - o), new M(e.lat + n, e.lng + o));\n    },\n    getCenter: function getCenter() {\n      return new M((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2);\n    },\n    getSouthWest: function getSouthWest() {\n      return this._southWest;\n    },\n    getNorthEast: function getNorthEast() {\n      return this._northEast;\n    },\n    getNorthWest: function getNorthWest() {\n      return new M(this.getNorth(), this.getWest());\n    },\n    getSouthEast: function getSouthEast() {\n      return new M(this.getSouth(), this.getEast());\n    },\n    getWest: function getWest() {\n      return this._southWest.lng;\n    },\n    getSouth: function getSouth() {\n      return this._southWest.lat;\n    },\n    getEast: function getEast() {\n      return this._northEast.lng;\n    },\n    getNorth: function getNorth() {\n      return this._northEast.lat;\n    },\n    contains: function contains(t) {\n      t = \"number\" == typeof t[0] || t instanceof M || \"lat\" in t ? C(t) : z(t);\n      var i,\n          e,\n          n = this._southWest,\n          o = this._northEast;\n      return t instanceof T ? (i = t.getSouthWest(), e = t.getNorthEast()) : i = e = t, i.lat >= n.lat && e.lat <= o.lat && i.lng >= n.lng && e.lng <= o.lng;\n    },\n    intersects: function intersects(t) {\n      t = z(t);\n      var i = this._southWest,\n          e = this._northEast,\n          n = t.getSouthWest(),\n          o = t.getNorthEast(),\n          s = o.lat >= i.lat && n.lat <= e.lat,\n          r = o.lng >= i.lng && n.lng <= e.lng;\n      return s && r;\n    },\n    overlaps: function overlaps(t) {\n      t = z(t);\n      var i = this._southWest,\n          e = this._northEast,\n          n = t.getSouthWest(),\n          o = t.getNorthEast(),\n          s = o.lat > i.lat && n.lat < e.lat,\n          r = o.lng > i.lng && n.lng < e.lng;\n      return s && r;\n    },\n    toBBoxString: function toBBoxString() {\n      return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(\",\");\n    },\n    equals: function equals(t, i) {\n      return !!t && (t = z(t), this._southWest.equals(t.getSouthWest(), i) && this._northEast.equals(t.getNorthEast(), i));\n    },\n    isValid: function isValid() {\n      return !(!this._southWest || !this._northEast);\n    }\n  }, M.prototype = {\n    equals: function equals(t, i) {\n      return !!t && (t = C(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === i ? 1e-9 : i));\n    },\n    toString: function toString(t) {\n      return \"LatLng(\" + a(this.lat, t) + \", \" + a(this.lng, t) + \")\";\n    },\n    distanceTo: function distanceTo(t) {\n      return pi.distance(this, C(t));\n    },\n    wrap: function wrap() {\n      return pi.wrapLatLng(this);\n    },\n    toBounds: function toBounds(t) {\n      var i = 180 * t / 40075017,\n          e = i / Math.cos(Math.PI / 180 * this.lat);\n      return z([this.lat - i, this.lng - e], [this.lat + i, this.lng + e]);\n    },\n    clone: function clone() {\n      return new M(this.lat, this.lng, this.alt);\n    }\n  };\n  var di = {\n    latLngToPoint: function latLngToPoint(t, i) {\n      var e = this.projection.project(t),\n          n = this.scale(i);\n      return this.transformation._transform(e, n);\n    },\n    pointToLatLng: function pointToLatLng(t, i) {\n      var e = this.scale(i),\n          n = this.transformation.untransform(t, e);\n      return this.projection.unproject(n);\n    },\n    project: function project(t) {\n      return this.projection.project(t);\n    },\n    unproject: function unproject(t) {\n      return this.projection.unproject(t);\n    },\n    scale: function scale(t) {\n      return 256 * Math.pow(2, t);\n    },\n    zoom: function zoom(t) {\n      return Math.log(t / 256) / Math.LN2;\n    },\n    getProjectedBounds: function getProjectedBounds(t) {\n      if (this.infinite) return null;\n      var i = this.projection.bounds,\n          e = this.scale(t);\n      return new P(this.transformation.transform(i.min, e), this.transformation.transform(i.max, e));\n    },\n    infinite: !1,\n    wrapLatLng: function wrapLatLng(t) {\n      var i = this.wrapLng ? s(t.lng, this.wrapLng, !0) : t.lng;\n      return new M(this.wrapLat ? s(t.lat, this.wrapLat, !0) : t.lat, i, t.alt);\n    },\n    wrapLatLngBounds: function wrapLatLngBounds(t) {\n      var i = t.getCenter(),\n          e = this.wrapLatLng(i),\n          n = i.lat - e.lat,\n          o = i.lng - e.lng;\n      if (0 === n && 0 === o) return t;\n      var s = t.getSouthWest(),\n          r = t.getNorthEast();\n      return new T(new M(s.lat - n, s.lng - o), new M(r.lat - n, r.lng - o));\n    }\n  },\n      pi = i({}, di, {\n    wrapLng: [-180, 180],\n    R: 6371e3,\n    distance: function distance(t, i) {\n      var e = Math.PI / 180,\n          n = t.lat * e,\n          o = i.lat * e,\n          s = Math.sin((i.lat - t.lat) * e / 2),\n          r = Math.sin((i.lng - t.lng) * e / 2),\n          a = s * s + Math.cos(n) * Math.cos(o) * r * r,\n          h = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n      return this.R * h;\n    }\n  }),\n      mi = {\n    R: 6378137,\n    MAX_LATITUDE: 85.0511287798,\n    project: function project(t) {\n      var i = Math.PI / 180,\n          e = this.MAX_LATITUDE,\n          n = Math.max(Math.min(e, t.lat), -e),\n          o = Math.sin(n * i);\n      return new x(this.R * t.lng * i, this.R * Math.log((1 + o) / (1 - o)) / 2);\n    },\n    unproject: function unproject(t) {\n      var i = 180 / Math.PI;\n      return new M((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * i, t.x * i / this.R);\n    },\n    bounds: function () {\n      var t = 6378137 * Math.PI;\n      return new P([-t, -t], [t, t]);\n    }()\n  };\n  S.prototype = {\n    transform: function transform(t, i) {\n      return this._transform(t.clone(), i);\n    },\n    _transform: function _transform(t, i) {\n      return i = i || 1, t.x = i * (this._a * t.x + this._b), t.y = i * (this._c * t.y + this._d), t;\n    },\n    untransform: function untransform(t, i) {\n      return i = i || 1, new x((t.x / i - this._b) / this._a, (t.y / i - this._d) / this._c);\n    }\n  };\n\n  var fi,\n      gi,\n      vi,\n      yi = i({}, pi, {\n    code: \"EPSG:3857\",\n    projection: mi,\n    transformation: function () {\n      var t = .5 / (Math.PI * mi.R);\n      return Z(t, .5, -t, .5);\n    }()\n  }),\n      xi = i({}, yi, {\n    code: \"EPSG:900913\"\n  }),\n      wi = document.documentElement.style,\n      Pi = \"ActiveXObject\" in window,\n      Li = Pi && !document.addEventListener,\n      bi = \"msLaunchUri\" in navigator && !(\"documentMode\" in document),\n      Ti = B(\"webkit\"),\n      zi = B(\"android\"),\n      Mi = B(\"android 2\") || B(\"android 3\"),\n      Ci = parseInt(/WebKit\\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10),\n      Si = zi && B(\"Google\") && Ci < 537 && !(\"AudioNode\" in window),\n      Zi = !!window.opera,\n      Ei = B(\"chrome\"),\n      ki = B(\"gecko\") && !Ti && !Zi && !Pi,\n      Bi = !Ei && B(\"safari\"),\n      Ai = B(\"phantom\"),\n      Ii = \"OTransition\" in wi,\n      Oi = 0 === navigator.platform.indexOf(\"Win\"),\n      Ri = Pi && \"transition\" in wi,\n      Ni = \"WebKitCSSMatrix\" in window && \"m11\" in new window.WebKitCSSMatrix() && !Mi,\n      Di = \"MozPerspective\" in wi,\n      ji = !window.L_DISABLE_3D && (Ri || Ni || Di) && !Ii && !Ai,\n      Wi = \"undefined\" != typeof orientation || B(\"mobile\"),\n      Hi = Wi && Ti,\n      Fi = Wi && Ni,\n      Ui = !window.PointerEvent && window.MSPointerEvent,\n      Vi = !(!window.PointerEvent && !Ui),\n      qi = !window.L_NO_TOUCH && (Vi || \"ontouchstart\" in window || window.DocumentTouch && document instanceof window.DocumentTouch),\n      Gi = Wi && Zi,\n      Ki = Wi && ki,\n      Yi = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1,\n      Xi = !!document.createElement(\"canvas\").getContext,\n      Ji = !(!document.createElementNS || !E(\"svg\").createSVGRect),\n      $i = !Ji && function () {\n    try {\n      var t = document.createElement(\"div\");\n      t.innerHTML = '<v:shape adj=\"1\"/>';\n      var i = t.firstChild;\n      return i.style.behavior = \"url(#default#VML)\", i && \"object\" == typeof i.adj;\n    } catch (t) {\n      return !1;\n    }\n  }(),\n      Qi = (Object.freeze || Object)({\n    ie: Pi,\n    ielt9: Li,\n    edge: bi,\n    webkit: Ti,\n    android: zi,\n    android23: Mi,\n    androidStock: Si,\n    opera: Zi,\n    chrome: Ei,\n    gecko: ki,\n    safari: Bi,\n    phantom: Ai,\n    opera12: Ii,\n    win: Oi,\n    ie3d: Ri,\n    webkit3d: Ni,\n    gecko3d: Di,\n    any3d: ji,\n    mobile: Wi,\n    mobileWebkit: Hi,\n    mobileWebkit3d: Fi,\n    msPointer: Ui,\n    pointer: Vi,\n    touch: qi,\n    mobileOpera: Gi,\n    mobileGecko: Ki,\n    retina: Yi,\n    canvas: Xi,\n    svg: Ji,\n    vml: $i\n  }),\n      te = Ui ? \"MSPointerDown\" : \"pointerdown\",\n      ie = Ui ? \"MSPointerMove\" : \"pointermove\",\n      ee = Ui ? \"MSPointerUp\" : \"pointerup\",\n      ne = Ui ? \"MSPointerCancel\" : \"pointercancel\",\n      oe = [\"INPUT\", \"SELECT\", \"OPTION\"],\n      se = {},\n      re = !1,\n      ae = 0,\n      he = Ui ? \"MSPointerDown\" : Vi ? \"pointerdown\" : \"touchstart\",\n      ue = Ui ? \"MSPointerUp\" : Vi ? \"pointerup\" : \"touchend\",\n      le = \"_leaflet_\",\n      ce = st([\"transform\", \"webkitTransform\", \"OTransform\", \"MozTransform\", \"msTransform\"]),\n      _e = st([\"webkitTransition\", \"transition\", \"OTransition\", \"MozTransition\", \"msTransition\"]),\n      de = \"webkitTransition\" === _e || \"OTransition\" === _e ? _e + \"End\" : \"transitionend\";\n\n  if (\"onselectstart\" in document) fi = function fi() {\n    mt(window, \"selectstart\", Pt);\n  }, gi = function gi() {\n    ft(window, \"selectstart\", Pt);\n  };else {\n    var pe = st([\"userSelect\", \"WebkitUserSelect\", \"OUserSelect\", \"MozUserSelect\", \"msUserSelect\"]);\n    fi = function fi() {\n      if (pe) {\n        var t = document.documentElement.style;\n        vi = t[pe], t[pe] = \"none\";\n      }\n    }, gi = function gi() {\n      pe && (document.documentElement.style[pe] = vi, vi = void 0);\n    };\n  }\n\n  var me,\n      fe,\n      ge,\n      ve = (Object.freeze || Object)({\n    TRANSFORM: ce,\n    TRANSITION: _e,\n    TRANSITION_END: de,\n    get: V,\n    getStyle: q,\n    create: G,\n    remove: K,\n    empty: Y,\n    toFront: X,\n    toBack: J,\n    hasClass: $,\n    addClass: Q,\n    removeClass: tt,\n    setClass: it,\n    getClass: et,\n    setOpacity: nt,\n    testProp: st,\n    setTransform: rt,\n    setPosition: at,\n    getPosition: ht,\n    disableTextSelection: fi,\n    enableTextSelection: gi,\n    disableImageDrag: ut,\n    enableImageDrag: lt,\n    preventOutline: ct,\n    restoreOutline: _t,\n    getSizedParentNode: dt,\n    getScale: pt\n  }),\n      ye = \"_leaflet_events\",\n      xe = Oi && Ei ? 2 * window.devicePixelRatio : ki ? window.devicePixelRatio : 1,\n      we = {},\n      Pe = (Object.freeze || Object)({\n    on: mt,\n    off: ft,\n    stopPropagation: yt,\n    disableScrollPropagation: xt,\n    disableClickPropagation: wt,\n    preventDefault: Pt,\n    stop: Lt,\n    getMousePosition: bt,\n    getWheelDelta: Tt,\n    fakeStop: zt,\n    skipped: Mt,\n    isExternalTarget: Ct,\n    addListener: mt,\n    removeListener: ft\n  }),\n      Le = ci.extend({\n    run: function run(t, i, e, n) {\n      this.stop(), this._el = t, this._inProgress = !0, this._duration = e || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = ht(t), this._offset = i.subtract(this._startPos), this._startTime = +new Date(), this.fire(\"start\"), this._animate();\n    },\n    stop: function stop() {\n      this._inProgress && (this._step(!0), this._complete());\n    },\n    _animate: function _animate() {\n      this._animId = f(this._animate, this), this._step();\n    },\n    _step: function _step(t) {\n      var i = +new Date() - this._startTime,\n          e = 1e3 * this._duration;\n      i < e ? this._runFrame(this._easeOut(i / e), t) : (this._runFrame(1), this._complete());\n    },\n    _runFrame: function _runFrame(t, i) {\n      var e = this._startPos.add(this._offset.multiplyBy(t));\n\n      i && e._round(), at(this._el, e), this.fire(\"step\");\n    },\n    _complete: function _complete() {\n      g(this._animId), this._inProgress = !1, this.fire(\"end\");\n    },\n    _easeOut: function _easeOut(t) {\n      return 1 - Math.pow(1 - t, this._easeOutPower);\n    }\n  }),\n      be = ci.extend({\n    options: {\n      crs: yi,\n      center: void 0,\n      zoom: void 0,\n      minZoom: void 0,\n      maxZoom: void 0,\n      layers: [],\n      maxBounds: void 0,\n      renderer: void 0,\n      zoomAnimation: !0,\n      zoomAnimationThreshold: 4,\n      fadeAnimation: !0,\n      markerZoomAnimation: !0,\n      transform3DLimit: 8388608,\n      zoomSnap: 1,\n      zoomDelta: 1,\n      trackResize: !0\n    },\n    initialize: function initialize(t, i) {\n      i = l(this, i), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = e(this._onResize, this), this._initEvents(), i.maxBounds && this.setMaxBounds(i.maxBounds), void 0 !== i.zoom && (this._zoom = this._limitZoom(i.zoom)), i.center && void 0 !== i.zoom && this.setView(C(i.center), i.zoom, {\n        reset: !0\n      }), this.callInitHooks(), this._zoomAnimated = _e && ji && !Gi && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), mt(this._proxy, de, this._catchTransitionEnd, this)), this._addLayers(this.options.layers);\n    },\n    setView: function setView(t, e, n) {\n      return e = void 0 === e ? this._zoom : this._limitZoom(e), t = this._limitCenter(C(t), e, this.options.maxBounds), n = n || {}, this._stop(), this._loaded && !n.reset && !0 !== n && (void 0 !== n.animate && (n.zoom = i({\n        animate: n.animate\n      }, n.zoom), n.pan = i({\n        animate: n.animate,\n        duration: n.duration\n      }, n.pan)), this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, n.zoom) : this._tryAnimatedPan(t, n.pan)) ? (clearTimeout(this._sizeTimer), this) : (this._resetView(t, e), this);\n    },\n    setZoom: function setZoom(t, i) {\n      return this._loaded ? this.setView(this.getCenter(), t, {\n        zoom: i\n      }) : (this._zoom = t, this);\n    },\n    zoomIn: function zoomIn(t, i) {\n      return t = t || (ji ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, i);\n    },\n    zoomOut: function zoomOut(t, i) {\n      return t = t || (ji ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, i);\n    },\n    setZoomAround: function setZoomAround(t, i, e) {\n      var n = this.getZoomScale(i),\n          o = this.getSize().divideBy(2),\n          s = (t instanceof x ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n),\n          r = this.containerPointToLatLng(o.add(s));\n      return this.setView(r, i, {\n        zoom: e\n      });\n    },\n    _getBoundsCenterZoom: function _getBoundsCenterZoom(t, i) {\n      i = i || {}, t = t.getBounds ? t.getBounds() : z(t);\n      var e = w(i.paddingTopLeft || i.padding || [0, 0]),\n          n = w(i.paddingBottomRight || i.padding || [0, 0]),\n          o = this.getBoundsZoom(t, !1, e.add(n));\n      if ((o = \"number\" == typeof i.maxZoom ? Math.min(i.maxZoom, o) : o) === 1 / 0) return {\n        center: t.getCenter(),\n        zoom: o\n      };\n      var s = n.subtract(e).divideBy(2),\n          r = this.project(t.getSouthWest(), o),\n          a = this.project(t.getNorthEast(), o);\n      return {\n        center: this.unproject(r.add(a).divideBy(2).add(s), o),\n        zoom: o\n      };\n    },\n    fitBounds: function fitBounds(t, i) {\n      if (!(t = z(t)).isValid()) throw new Error(\"Bounds are not valid.\");\n\n      var e = this._getBoundsCenterZoom(t, i);\n\n      return this.setView(e.center, e.zoom, i);\n    },\n    fitWorld: function fitWorld(t) {\n      return this.fitBounds([[-90, -180], [90, 180]], t);\n    },\n    panTo: function panTo(t, i) {\n      return this.setView(t, this._zoom, {\n        pan: i\n      });\n    },\n    panBy: function panBy(t, i) {\n      if (t = w(t).round(), i = i || {}, !t.x && !t.y) return this.fire(\"moveend\");\n      if (!0 !== i.animate && !this.getSize().contains(t)) return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this;\n\n      if (this._panAnim || (this._panAnim = new Le(), this._panAnim.on({\n        step: this._onPanTransitionStep,\n        end: this._onPanTransitionEnd\n      }, this)), i.noMoveStart || this.fire(\"movestart\"), !1 !== i.animate) {\n        Q(this._mapPane, \"leaflet-pan-anim\");\n\n        var e = this._getMapPanePos().subtract(t).round();\n\n        this._panAnim.run(this._mapPane, e, i.duration || .25, i.easeLinearity);\n      } else this._rawPanBy(t), this.fire(\"move\").fire(\"moveend\");\n\n      return this;\n    },\n    flyTo: function flyTo(t, i, e) {\n      function n(t) {\n        var i = (g * g - m * m + (t ? -1 : 1) * x * x * v * v) / (2 * (t ? g : m) * x * v),\n            e = Math.sqrt(i * i + 1) - i;\n        return e < 1e-9 ? -18 : Math.log(e);\n      }\n\n      function o(t) {\n        return (Math.exp(t) - Math.exp(-t)) / 2;\n      }\n\n      function s(t) {\n        return (Math.exp(t) + Math.exp(-t)) / 2;\n      }\n\n      function r(t) {\n        return o(t) / s(t);\n      }\n\n      function a(t) {\n        return m * (s(w) / s(w + y * t));\n      }\n\n      function h(t) {\n        return m * (s(w) * r(w + y * t) - o(w)) / x;\n      }\n\n      function u(t) {\n        return 1 - Math.pow(1 - t, 1.5);\n      }\n\n      function l() {\n        var e = (Date.now() - P) / b,\n            n = u(e) * L;\n        e <= 1 ? (this._flyToFrame = f(l, this), this._move(this.unproject(c.add(_.subtract(c).multiplyBy(h(n) / v)), p), this.getScaleZoom(m / a(n), p), {\n          flyTo: !0\n        })) : this._move(t, i)._moveEnd(!0);\n      }\n\n      if (!1 === (e = e || {}).animate || !ji) return this.setView(t, i, e);\n\n      this._stop();\n\n      var c = this.project(this.getCenter()),\n          _ = this.project(t),\n          d = this.getSize(),\n          p = this._zoom;\n\n      t = C(t), i = void 0 === i ? p : i;\n      var m = Math.max(d.x, d.y),\n          g = m * this.getZoomScale(p, i),\n          v = _.distanceTo(c) || 1,\n          y = 1.42,\n          x = y * y,\n          w = n(0),\n          P = Date.now(),\n          L = (n(1) - w) / y,\n          b = e.duration ? 1e3 * e.duration : 1e3 * L * .8;\n      return this._moveStart(!0, e.noMoveStart), l.call(this), this;\n    },\n    flyToBounds: function flyToBounds(t, i) {\n      var e = this._getBoundsCenterZoom(t, i);\n\n      return this.flyTo(e.center, e.zoom, i);\n    },\n    setMaxBounds: function setMaxBounds(t) {\n      return (t = z(t)).isValid() ? (this.options.maxBounds && this.off(\"moveend\", this._panInsideMaxBounds), this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on(\"moveend\", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this.off(\"moveend\", this._panInsideMaxBounds));\n    },\n    setMinZoom: function setMinZoom(t) {\n      var i = this.options.minZoom;\n      return this.options.minZoom = t, this._loaded && i !== t && (this.fire(\"zoomlevelschange\"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this;\n    },\n    setMaxZoom: function setMaxZoom(t) {\n      var i = this.options.maxZoom;\n      return this.options.maxZoom = t, this._loaded && i !== t && (this.fire(\"zoomlevelschange\"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this;\n    },\n    panInsideBounds: function panInsideBounds(t, i) {\n      this._enforcingBounds = !0;\n\n      var e = this.getCenter(),\n          n = this._limitCenter(e, this._zoom, z(t));\n\n      return e.equals(n) || this.panTo(n, i), this._enforcingBounds = !1, this;\n    },\n    panInside: function panInside(t, i) {\n      var e = w((i = i || {}).paddingTopLeft || i.padding || [0, 0]),\n          n = w(i.paddingBottomRight || i.padding || [0, 0]),\n          o = this.getCenter(),\n          s = this.project(o),\n          r = this.project(t),\n          a = this.getPixelBounds(),\n          h = a.getSize().divideBy(2),\n          u = b([a.min.add(e), a.max.subtract(n)]);\n\n      if (!u.contains(r)) {\n        this._enforcingBounds = !0;\n        var l = s.subtract(r),\n            c = w(r.x + l.x, r.y + l.y);\n        (r.x < u.min.x || r.x > u.max.x) && (c.x = s.x - l.x, l.x > 0 ? c.x += h.x - e.x : c.x -= h.x - n.x), (r.y < u.min.y || r.y > u.max.y) && (c.y = s.y - l.y, l.y > 0 ? c.y += h.y - e.y : c.y -= h.y - n.y), this.panTo(this.unproject(c), i), this._enforcingBounds = !1;\n      }\n\n      return this;\n    },\n    invalidateSize: function invalidateSize(t) {\n      if (!this._loaded) return this;\n      t = i({\n        animate: !1,\n        pan: !0\n      }, !0 === t ? {\n        animate: !0\n      } : t);\n      var n = this.getSize();\n      this._sizeChanged = !0, this._lastCenter = null;\n      var o = this.getSize(),\n          s = n.divideBy(2).round(),\n          r = o.divideBy(2).round(),\n          a = s.subtract(r);\n      return a.x || a.y ? (t.animate && t.pan ? this.panBy(a) : (t.pan && this._rawPanBy(a), this.fire(\"move\"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(e(this.fire, this, \"moveend\"), 200)) : this.fire(\"moveend\")), this.fire(\"resize\", {\n        oldSize: n,\n        newSize: o\n      })) : this;\n    },\n    stop: function stop() {\n      return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire(\"viewreset\"), this._stop();\n    },\n    locate: function locate(t) {\n      if (t = this._locateOptions = i({\n        timeout: 1e4,\n        watch: !1\n      }, t), !(\"geolocation\" in navigator)) return this._handleGeolocationError({\n        code: 0,\n        message: \"Geolocation not supported.\"\n      }), this;\n      var n = e(this._handleGeolocationResponse, this),\n          o = e(this._handleGeolocationError, this);\n      return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(n, o, t) : navigator.geolocation.getCurrentPosition(n, o, t), this;\n    },\n    stopLocate: function stopLocate() {\n      return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this;\n    },\n    _handleGeolocationError: function _handleGeolocationError(t) {\n      var i = t.code,\n          e = t.message || (1 === i ? \"permission denied\" : 2 === i ? \"position unavailable\" : \"timeout\");\n      this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire(\"locationerror\", {\n        code: i,\n        message: \"Geolocation error: \" + e + \".\"\n      });\n    },\n    _handleGeolocationResponse: function _handleGeolocationResponse(t) {\n      var i = new M(t.coords.latitude, t.coords.longitude),\n          e = i.toBounds(2 * t.coords.accuracy),\n          n = this._locateOptions;\n\n      if (n.setView) {\n        var o = this.getBoundsZoom(e);\n        this.setView(i, n.maxZoom ? Math.min(o, n.maxZoom) : o);\n      }\n\n      var s = {\n        latlng: i,\n        bounds: e,\n        timestamp: t.timestamp\n      };\n\n      for (var r in t.coords) {\n        \"number\" == typeof t.coords[r] && (s[r] = t.coords[r]);\n      }\n\n      this.fire(\"locationfound\", s);\n    },\n    addHandler: function addHandler(t, i) {\n      if (!i) return this;\n      var e = this[t] = new i(this);\n      return this._handlers.push(e), this.options[t] && e.enable(), this;\n    },\n    remove: function remove() {\n      if (this._initEvents(!0), this._containerId !== this._container._leaflet_id) throw new Error(\"Map container is being reused by another instance\");\n\n      try {\n        delete this._container._leaflet_id, delete this._containerId;\n      } catch (t) {\n        this._container._leaflet_id = void 0, this._containerId = void 0;\n      }\n\n      void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), K(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (g(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire(\"unload\");\n      var t;\n\n      for (t in this._layers) {\n        this._layers[t].remove();\n      }\n\n      for (t in this._panes) {\n        K(this._panes[t]);\n      }\n\n      return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this;\n    },\n    createPane: function createPane(t, i) {\n      var e = G(\"div\", \"leaflet-pane\" + (t ? \" leaflet-\" + t.replace(\"Pane\", \"\") + \"-pane\" : \"\"), i || this._mapPane);\n      return t && (this._panes[t] = e), e;\n    },\n    getCenter: function getCenter() {\n      return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter : this.layerPointToLatLng(this._getCenterLayerPoint());\n    },\n    getZoom: function getZoom() {\n      return this._zoom;\n    },\n    getBounds: function getBounds() {\n      var t = this.getPixelBounds();\n      return new T(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight()));\n    },\n    getMinZoom: function getMinZoom() {\n      return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom;\n    },\n    getMaxZoom: function getMaxZoom() {\n      return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom;\n    },\n    getBoundsZoom: function getBoundsZoom(t, i, e) {\n      t = z(t), e = w(e || [0, 0]);\n\n      var n = this.getZoom() || 0,\n          o = this.getMinZoom(),\n          s = this.getMaxZoom(),\n          r = t.getNorthWest(),\n          a = t.getSouthEast(),\n          h = this.getSize().subtract(e),\n          u = b(this.project(a, n), this.project(r, n)).getSize(),\n          l = ji ? this.options.zoomSnap : 1,\n          c = h.x / u.x,\n          _ = h.y / u.y,\n          d = i ? Math.max(c, _) : Math.min(c, _);\n\n      return n = this.getScaleZoom(d, n), l && (n = Math.round(n / (l / 100)) * (l / 100), n = i ? Math.ceil(n / l) * l : Math.floor(n / l) * l), Math.max(o, Math.min(s, n));\n    },\n    getSize: function getSize() {\n      return this._size && !this._sizeChanged || (this._size = new x(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone();\n    },\n    getPixelBounds: function getPixelBounds(t, i) {\n      var e = this._getTopLeftPoint(t, i);\n\n      return new P(e, e.add(this.getSize()));\n    },\n    getPixelOrigin: function getPixelOrigin() {\n      return this._checkIfLoaded(), this._pixelOrigin;\n    },\n    getPixelWorldBounds: function getPixelWorldBounds(t) {\n      return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t);\n    },\n    getPane: function getPane(t) {\n      return \"string\" == typeof t ? this._panes[t] : t;\n    },\n    getPanes: function getPanes() {\n      return this._panes;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    getZoomScale: function getZoomScale(t, i) {\n      var e = this.options.crs;\n      return i = void 0 === i ? this._zoom : i, e.scale(t) / e.scale(i);\n    },\n    getScaleZoom: function getScaleZoom(t, i) {\n      var e = this.options.crs;\n      i = void 0 === i ? this._zoom : i;\n      var n = e.zoom(t * e.scale(i));\n      return isNaN(n) ? 1 / 0 : n;\n    },\n    project: function project(t, i) {\n      return i = void 0 === i ? this._zoom : i, this.options.crs.latLngToPoint(C(t), i);\n    },\n    unproject: function unproject(t, i) {\n      return i = void 0 === i ? this._zoom : i, this.options.crs.pointToLatLng(w(t), i);\n    },\n    layerPointToLatLng: function layerPointToLatLng(t) {\n      var i = w(t).add(this.getPixelOrigin());\n      return this.unproject(i);\n    },\n    latLngToLayerPoint: function latLngToLayerPoint(t) {\n      return this.project(C(t))._round()._subtract(this.getPixelOrigin());\n    },\n    wrapLatLng: function wrapLatLng(t) {\n      return this.options.crs.wrapLatLng(C(t));\n    },\n    wrapLatLngBounds: function wrapLatLngBounds(t) {\n      return this.options.crs.wrapLatLngBounds(z(t));\n    },\n    distance: function distance(t, i) {\n      return this.options.crs.distance(C(t), C(i));\n    },\n    containerPointToLayerPoint: function containerPointToLayerPoint(t) {\n      return w(t).subtract(this._getMapPanePos());\n    },\n    layerPointToContainerPoint: function layerPointToContainerPoint(t) {\n      return w(t).add(this._getMapPanePos());\n    },\n    containerPointToLatLng: function containerPointToLatLng(t) {\n      var i = this.containerPointToLayerPoint(w(t));\n      return this.layerPointToLatLng(i);\n    },\n    latLngToContainerPoint: function latLngToContainerPoint(t) {\n      return this.layerPointToContainerPoint(this.latLngToLayerPoint(C(t)));\n    },\n    mouseEventToContainerPoint: function mouseEventToContainerPoint(t) {\n      return bt(t, this._container);\n    },\n    mouseEventToLayerPoint: function mouseEventToLayerPoint(t) {\n      return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t));\n    },\n    mouseEventToLatLng: function mouseEventToLatLng(t) {\n      return this.layerPointToLatLng(this.mouseEventToLayerPoint(t));\n    },\n    _initContainer: function _initContainer(t) {\n      var i = this._container = V(t);\n      if (!i) throw new Error(\"Map container not found.\");\n      if (i._leaflet_id) throw new Error(\"Map container is already initialized.\");\n      mt(i, \"scroll\", this._onScroll, this), this._containerId = n(i);\n    },\n    _initLayout: function _initLayout() {\n      var t = this._container;\n      this._fadeAnimated = this.options.fadeAnimation && ji, Q(t, \"leaflet-container\" + (qi ? \" leaflet-touch\" : \"\") + (Yi ? \" leaflet-retina\" : \"\") + (Li ? \" leaflet-oldie\" : \"\") + (Bi ? \" leaflet-safari\" : \"\") + (this._fadeAnimated ? \" leaflet-fade-anim\" : \"\"));\n      var i = q(t, \"position\");\n      \"absolute\" !== i && \"relative\" !== i && \"fixed\" !== i && (t.style.position = \"relative\"), this._initPanes(), this._initControlPos && this._initControlPos();\n    },\n    _initPanes: function _initPanes() {\n      var t = this._panes = {};\n      this._paneRenderers = {}, this._mapPane = this.createPane(\"mapPane\", this._container), at(this._mapPane, new x(0, 0)), this.createPane(\"tilePane\"), this.createPane(\"shadowPane\"), this.createPane(\"overlayPane\"), this.createPane(\"markerPane\"), this.createPane(\"tooltipPane\"), this.createPane(\"popupPane\"), this.options.markerZoomAnimation || (Q(t.markerPane, \"leaflet-zoom-hide\"), Q(t.shadowPane, \"leaflet-zoom-hide\"));\n    },\n    _resetView: function _resetView(t, i) {\n      at(this._mapPane, new x(0, 0));\n      var e = !this._loaded;\n      this._loaded = !0, i = this._limitZoom(i), this.fire(\"viewprereset\");\n      var n = this._zoom !== i;\n      this._moveStart(n, !1)._move(t, i)._moveEnd(n), this.fire(\"viewreset\"), e && this.fire(\"load\");\n    },\n    _moveStart: function _moveStart(t, i) {\n      return t && this.fire(\"zoomstart\"), i || this.fire(\"movestart\"), this;\n    },\n    _move: function _move(t, i, e) {\n      void 0 === i && (i = this._zoom);\n      var n = this._zoom !== i;\n      return this._zoom = i, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), (n || e && e.pinch) && this.fire(\"zoom\", e), this.fire(\"move\", e);\n    },\n    _moveEnd: function _moveEnd(t) {\n      return t && this.fire(\"zoomend\"), this.fire(\"moveend\");\n    },\n    _stop: function _stop() {\n      return g(this._flyToFrame), this._panAnim && this._panAnim.stop(), this;\n    },\n    _rawPanBy: function _rawPanBy(t) {\n      at(this._mapPane, this._getMapPanePos().subtract(t));\n    },\n    _getZoomSpan: function _getZoomSpan() {\n      return this.getMaxZoom() - this.getMinZoom();\n    },\n    _panInsideMaxBounds: function _panInsideMaxBounds() {\n      this._enforcingBounds || this.panInsideBounds(this.options.maxBounds);\n    },\n    _checkIfLoaded: function _checkIfLoaded() {\n      if (!this._loaded) throw new Error(\"Set map center and zoom first.\");\n    },\n    _initEvents: function _initEvents(t) {\n      this._targets = {}, this._targets[n(this._container)] = this;\n      var i = t ? ft : mt;\n      i(this._container, \"click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress\", this._handleDOMEvent, this), this.options.trackResize && i(window, \"resize\", this._onResize, this), ji && this.options.transform3DLimit && (t ? this.off : this.on).call(this, \"moveend\", this._onMoveEnd);\n    },\n    _onResize: function _onResize() {\n      g(this._resizeRequest), this._resizeRequest = f(function () {\n        this.invalidateSize({\n          debounceMoveend: !0\n        });\n      }, this);\n    },\n    _onScroll: function _onScroll() {\n      this._container.scrollTop = 0, this._container.scrollLeft = 0;\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      var t = this._getMapPanePos();\n\n      Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom());\n    },\n    _findEventTargets: function _findEventTargets(t, i) {\n      for (var e, o = [], s = \"mouseout\" === i || \"mouseover\" === i, r = t.target || t.srcElement, a = !1; r;) {\n        if ((e = this._targets[n(r)]) && (\"click\" === i || \"preclick\" === i) && !t._simulated && this._draggableMoved(e)) {\n          a = !0;\n          break;\n        }\n\n        if (e && e.listens(i, !0)) {\n          if (s && !Ct(r, t)) break;\n          if (o.push(e), s) break;\n        }\n\n        if (r === this._container) break;\n        r = r.parentNode;\n      }\n\n      return o.length || a || s || !Ct(r, t) || (o = [this]), o;\n    },\n    _handleDOMEvent: function _handleDOMEvent(t) {\n      if (this._loaded && !Mt(t)) {\n        var i = t.type;\n        \"mousedown\" !== i && \"keypress\" !== i || ct(t.target || t.srcElement), this._fireDOMEvent(t, i);\n      }\n    },\n    _mouseEvents: [\"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"contextmenu\"],\n    _fireDOMEvent: function _fireDOMEvent(t, e, n) {\n      if (\"click\" === t.type) {\n        var o = i({}, t);\n        o.type = \"preclick\", this._fireDOMEvent(o, o.type, n);\n      }\n\n      if (!t._stopped && (n = (n || []).concat(this._findEventTargets(t, e))).length) {\n        var s = n[0];\n        \"contextmenu\" === e && s.listens(e, !0) && Pt(t);\n        var r = {\n          originalEvent: t\n        };\n\n        if (\"keypress\" !== t.type) {\n          var a = s.getLatLng && (!s._radius || s._radius <= 10);\n          r.containerPoint = a ? this.latLngToContainerPoint(s.getLatLng()) : this.mouseEventToContainerPoint(t), r.layerPoint = this.containerPointToLayerPoint(r.containerPoint), r.latlng = a ? s.getLatLng() : this.layerPointToLatLng(r.layerPoint);\n        }\n\n        for (var h = 0; h < n.length; h++) {\n          if (n[h].fire(e, r, !0), r.originalEvent._stopped || !1 === n[h].options.bubblingMouseEvents && -1 !== d(this._mouseEvents, e)) return;\n        }\n      }\n    },\n    _draggableMoved: function _draggableMoved(t) {\n      return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved();\n    },\n    _clearHandlers: function _clearHandlers() {\n      for (var t = 0, i = this._handlers.length; t < i; t++) {\n        this._handlers[t].disable();\n      }\n    },\n    whenReady: function whenReady(t, i) {\n      return this._loaded ? t.call(i || this, {\n        target: this\n      }) : this.on(\"load\", t, i), this;\n    },\n    _getMapPanePos: function _getMapPanePos() {\n      return ht(this._mapPane) || new x(0, 0);\n    },\n    _moved: function _moved() {\n      var t = this._getMapPanePos();\n\n      return t && !t.equals([0, 0]);\n    },\n    _getTopLeftPoint: function _getTopLeftPoint(t, i) {\n      return (t && void 0 !== i ? this._getNewPixelOrigin(t, i) : this.getPixelOrigin()).subtract(this._getMapPanePos());\n    },\n    _getNewPixelOrigin: function _getNewPixelOrigin(t, i) {\n      var e = this.getSize()._divideBy(2);\n\n      return this.project(t, i)._subtract(e)._add(this._getMapPanePos())._round();\n    },\n    _latLngToNewLayerPoint: function _latLngToNewLayerPoint(t, i, e) {\n      var n = this._getNewPixelOrigin(e, i);\n\n      return this.project(t, i)._subtract(n);\n    },\n    _latLngBoundsToNewLayerBounds: function _latLngBoundsToNewLayerBounds(t, i, e) {\n      var n = this._getNewPixelOrigin(e, i);\n\n      return b([this.project(t.getSouthWest(), i)._subtract(n), this.project(t.getNorthWest(), i)._subtract(n), this.project(t.getSouthEast(), i)._subtract(n), this.project(t.getNorthEast(), i)._subtract(n)]);\n    },\n    _getCenterLayerPoint: function _getCenterLayerPoint() {\n      return this.containerPointToLayerPoint(this.getSize()._divideBy(2));\n    },\n    _getCenterOffset: function _getCenterOffset(t) {\n      return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint());\n    },\n    _limitCenter: function _limitCenter(t, i, e) {\n      if (!e) return t;\n\n      var n = this.project(t, i),\n          o = this.getSize().divideBy(2),\n          s = new P(n.subtract(o), n.add(o)),\n          r = this._getBoundsOffset(s, e, i);\n\n      return r.round().equals([0, 0]) ? t : this.unproject(n.add(r), i);\n    },\n    _limitOffset: function _limitOffset(t, i) {\n      if (!i) return t;\n      var e = this.getPixelBounds(),\n          n = new P(e.min.add(t), e.max.add(t));\n      return t.add(this._getBoundsOffset(n, i));\n    },\n    _getBoundsOffset: function _getBoundsOffset(t, i, e) {\n      var n = b(this.project(i.getNorthEast(), e), this.project(i.getSouthWest(), e)),\n          o = n.min.subtract(t.min),\n          s = n.max.subtract(t.max);\n      return new x(this._rebound(o.x, -s.x), this._rebound(o.y, -s.y));\n    },\n    _rebound: function _rebound(t, i) {\n      return t + i > 0 ? Math.round(t - i) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(i));\n    },\n    _limitZoom: function _limitZoom(t) {\n      var i = this.getMinZoom(),\n          e = this.getMaxZoom(),\n          n = ji ? this.options.zoomSnap : 1;\n      return n && (t = Math.round(t / n) * n), Math.max(i, Math.min(e, t));\n    },\n    _onPanTransitionStep: function _onPanTransitionStep() {\n      this.fire(\"move\");\n    },\n    _onPanTransitionEnd: function _onPanTransitionEnd() {\n      tt(this._mapPane, \"leaflet-pan-anim\"), this.fire(\"moveend\");\n    },\n    _tryAnimatedPan: function _tryAnimatedPan(t, i) {\n      var e = this._getCenterOffset(t)._trunc();\n\n      return !(!0 !== (i && i.animate) && !this.getSize().contains(e)) && (this.panBy(e, i), !0);\n    },\n    _createAnimProxy: function _createAnimProxy() {\n      var t = this._proxy = G(\"div\", \"leaflet-proxy leaflet-zoom-animated\");\n      this._panes.mapPane.appendChild(t), this.on(\"zoomanim\", function (t) {\n        var i = ce,\n            e = this._proxy.style[i];\n        rt(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), e === this._proxy.style[i] && this._animatingZoom && this._onZoomTransitionEnd();\n      }, this), this.on(\"load moveend\", function () {\n        var t = this.getCenter(),\n            i = this.getZoom();\n        rt(this._proxy, this.project(t, i), this.getZoomScale(i, 1));\n      }, this), this._on(\"unload\", this._destroyAnimProxy, this);\n    },\n    _destroyAnimProxy: function _destroyAnimProxy() {\n      K(this._proxy), delete this._proxy;\n    },\n    _catchTransitionEnd: function _catchTransitionEnd(t) {\n      this._animatingZoom && t.propertyName.indexOf(\"transform\") >= 0 && this._onZoomTransitionEnd();\n    },\n    _nothingToAnimate: function _nothingToAnimate() {\n      return !this._container.getElementsByClassName(\"leaflet-zoom-animated\").length;\n    },\n    _tryAnimatedZoom: function _tryAnimatedZoom(t, i, e) {\n      if (this._animatingZoom) return !0;\n      if (e = e || {}, !this._zoomAnimated || !1 === e.animate || this._nothingToAnimate() || Math.abs(i - this._zoom) > this.options.zoomAnimationThreshold) return !1;\n\n      var n = this.getZoomScale(i),\n          o = this._getCenterOffset(t)._divideBy(1 - 1 / n);\n\n      return !(!0 !== e.animate && !this.getSize().contains(o)) && (f(function () {\n        this._moveStart(!0, !1)._animateZoom(t, i, !0);\n      }, this), !0);\n    },\n    _animateZoom: function _animateZoom(t, i, n, o) {\n      this._mapPane && (n && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = i, Q(this._mapPane, \"leaflet-zoom-anim\")), this.fire(\"zoomanim\", {\n        center: t,\n        zoom: i,\n        noUpdate: o\n      }), setTimeout(e(this._onZoomTransitionEnd, this), 250));\n    },\n    _onZoomTransitionEnd: function _onZoomTransitionEnd() {\n      this._animatingZoom && (this._mapPane && tt(this._mapPane, \"leaflet-zoom-anim\"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom), f(function () {\n        this._moveEnd(!0);\n      }, this));\n    }\n  }),\n      Te = v.extend({\n    options: {\n      position: \"topright\"\n    },\n    initialize: function initialize(t) {\n      l(this, t);\n    },\n    getPosition: function getPosition() {\n      return this.options.position;\n    },\n    setPosition: function setPosition(t) {\n      var i = this._map;\n      return i && i.removeControl(this), this.options.position = t, i && i.addControl(this), this;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    addTo: function addTo(t) {\n      this.remove(), this._map = t;\n      var i = this._container = this.onAdd(t),\n          e = this.getPosition(),\n          n = t._controlCorners[e];\n      return Q(i, \"leaflet-control\"), -1 !== e.indexOf(\"bottom\") ? n.insertBefore(i, n.firstChild) : n.appendChild(i), this;\n    },\n    remove: function remove() {\n      return this._map ? (K(this._container), this.onRemove && this.onRemove(this._map), this._map = null, this) : this;\n    },\n    _refocusOnMap: function _refocusOnMap(t) {\n      this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus();\n    }\n  }),\n      ze = function ze(t) {\n    return new Te(t);\n  };\n\n  be.include({\n    addControl: function addControl(t) {\n      return t.addTo(this), this;\n    },\n    removeControl: function removeControl(t) {\n      return t.remove(), this;\n    },\n    _initControlPos: function _initControlPos() {\n      function t(t, o) {\n        var s = e + t + \" \" + e + o;\n        i[t + o] = G(\"div\", s, n);\n      }\n\n      var i = this._controlCorners = {},\n          e = \"leaflet-\",\n          n = this._controlContainer = G(\"div\", e + \"control-container\", this._container);\n      t(\"top\", \"left\"), t(\"top\", \"right\"), t(\"bottom\", \"left\"), t(\"bottom\", \"right\");\n    },\n    _clearControlPos: function _clearControlPos() {\n      for (var t in this._controlCorners) {\n        K(this._controlCorners[t]);\n      }\n\n      K(this._controlContainer), delete this._controlCorners, delete this._controlContainer;\n    }\n  });\n  var Me = Te.extend({\n    options: {\n      collapsed: !0,\n      position: \"topright\",\n      autoZIndex: !0,\n      hideSingleBase: !1,\n      sortLayers: !1,\n      sortFunction: function sortFunction(t, i, e, n) {\n        return e < n ? -1 : n < e ? 1 : 0;\n      }\n    },\n    initialize: function initialize(t, i, e) {\n      l(this, e), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1;\n\n      for (var n in t) {\n        this._addLayer(t[n], n);\n      }\n\n      for (n in i) {\n        this._addLayer(i[n], n, !0);\n      }\n    },\n    onAdd: function onAdd(t) {\n      this._initLayout(), this._update(), this._map = t, t.on(\"zoomend\", this._checkDisabledLayers, this);\n\n      for (var i = 0; i < this._layers.length; i++) {\n        this._layers[i].layer.on(\"add remove\", this._onLayerChange, this);\n      }\n\n      return this._container;\n    },\n    addTo: function addTo(t) {\n      return Te.prototype.addTo.call(this, t), this._expandIfNotCollapsed();\n    },\n    onRemove: function onRemove() {\n      this._map.off(\"zoomend\", this._checkDisabledLayers, this);\n\n      for (var t = 0; t < this._layers.length; t++) {\n        this._layers[t].layer.off(\"add remove\", this._onLayerChange, this);\n      }\n    },\n    addBaseLayer: function addBaseLayer(t, i) {\n      return this._addLayer(t, i), this._map ? this._update() : this;\n    },\n    addOverlay: function addOverlay(t, i) {\n      return this._addLayer(t, i, !0), this._map ? this._update() : this;\n    },\n    removeLayer: function removeLayer(t) {\n      t.off(\"add remove\", this._onLayerChange, this);\n\n      var i = this._getLayer(n(t));\n\n      return i && this._layers.splice(this._layers.indexOf(i), 1), this._map ? this._update() : this;\n    },\n    expand: function expand() {\n      Q(this._container, \"leaflet-control-layers-expanded\"), this._section.style.height = null;\n      var t = this._map.getSize().y - (this._container.offsetTop + 50);\n      return t < this._section.clientHeight ? (Q(this._section, \"leaflet-control-layers-scrollbar\"), this._section.style.height = t + \"px\") : tt(this._section, \"leaflet-control-layers-scrollbar\"), this._checkDisabledLayers(), this;\n    },\n    collapse: function collapse() {\n      return tt(this._container, \"leaflet-control-layers-expanded\"), this;\n    },\n    _initLayout: function _initLayout() {\n      var t = \"leaflet-control-layers\",\n          i = this._container = G(\"div\", t),\n          e = this.options.collapsed;\n      i.setAttribute(\"aria-haspopup\", !0), wt(i), xt(i);\n      var n = this._section = G(\"section\", t + \"-list\");\n      e && (this._map.on(\"click\", this.collapse, this), zi || mt(i, {\n        mouseenter: this.expand,\n        mouseleave: this.collapse\n      }, this));\n      var o = this._layersLink = G(\"a\", t + \"-toggle\", i);\n      o.href = \"#\", o.title = \"Layers\", qi ? (mt(o, \"click\", Lt), mt(o, \"click\", this.expand, this)) : mt(o, \"focus\", this.expand, this), e || this.expand(), this._baseLayersList = G(\"div\", t + \"-base\", n), this._separator = G(\"div\", t + \"-separator\", n), this._overlaysList = G(\"div\", t + \"-overlays\", n), i.appendChild(n);\n    },\n    _getLayer: function _getLayer(t) {\n      for (var i = 0; i < this._layers.length; i++) {\n        if (this._layers[i] && n(this._layers[i].layer) === t) return this._layers[i];\n      }\n    },\n    _addLayer: function _addLayer(t, i, n) {\n      this._map && t.on(\"add remove\", this._onLayerChange, this), this._layers.push({\n        layer: t,\n        name: i,\n        overlay: n\n      }), this.options.sortLayers && this._layers.sort(e(function (t, i) {\n        return this.options.sortFunction(t.layer, i.layer, t.name, i.name);\n      }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed();\n    },\n    _update: function _update() {\n      if (!this._container) return this;\n      Y(this._baseLayersList), Y(this._overlaysList), this._layerControlInputs = [];\n      var t,\n          i,\n          e,\n          n,\n          o = 0;\n\n      for (e = 0; e < this._layers.length; e++) {\n        n = this._layers[e], this._addItem(n), i = i || n.overlay, t = t || !n.overlay, o += n.overlay ? 0 : 1;\n      }\n\n      return this.options.hideSingleBase && (t = t && o > 1, this._baseLayersList.style.display = t ? \"\" : \"none\"), this._separator.style.display = i && t ? \"\" : \"none\", this;\n    },\n    _onLayerChange: function _onLayerChange(t) {\n      this._handlingClick || this._update();\n\n      var i = this._getLayer(n(t.target)),\n          e = i.overlay ? \"add\" === t.type ? \"overlayadd\" : \"overlayremove\" : \"add\" === t.type ? \"baselayerchange\" : null;\n\n      e && this._map.fire(e, i);\n    },\n    _createRadioElement: function _createRadioElement(t, i) {\n      var e = '<input type=\"radio\" class=\"leaflet-control-layers-selector\" name=\"' + t + '\"' + (i ? ' checked=\"checked\"' : \"\") + \"/>\",\n          n = document.createElement(\"div\");\n      return n.innerHTML = e, n.firstChild;\n    },\n    _addItem: function _addItem(t) {\n      var i,\n          e = document.createElement(\"label\"),\n          o = this._map.hasLayer(t.layer);\n\n      t.overlay ? ((i = document.createElement(\"input\")).type = \"checkbox\", i.className = \"leaflet-control-layers-selector\", i.defaultChecked = o) : i = this._createRadioElement(\"leaflet-base-layers\", o), this._layerControlInputs.push(i), i.layerId = n(t.layer), mt(i, \"click\", this._onInputClick, this);\n      var s = document.createElement(\"span\");\n      s.innerHTML = \" \" + t.name;\n      var r = document.createElement(\"div\");\n      return e.appendChild(r), r.appendChild(i), r.appendChild(s), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(e), this._checkDisabledLayers(), e;\n    },\n    _onInputClick: function _onInputClick() {\n      var t,\n          i,\n          e = this._layerControlInputs,\n          n = [],\n          o = [];\n      this._handlingClick = !0;\n\n      for (var s = e.length - 1; s >= 0; s--) {\n        t = e[s], i = this._getLayer(t.layerId).layer, t.checked ? n.push(i) : t.checked || o.push(i);\n      }\n\n      for (s = 0; s < o.length; s++) {\n        this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]);\n      }\n\n      for (s = 0; s < n.length; s++) {\n        this._map.hasLayer(n[s]) || this._map.addLayer(n[s]);\n      }\n\n      this._handlingClick = !1, this._refocusOnMap();\n    },\n    _checkDisabledLayers: function _checkDisabledLayers() {\n      for (var t, i, e = this._layerControlInputs, n = this._map.getZoom(), o = e.length - 1; o >= 0; o--) {\n        t = e[o], i = this._getLayer(t.layerId).layer, t.disabled = void 0 !== i.options.minZoom && n < i.options.minZoom || void 0 !== i.options.maxZoom && n > i.options.maxZoom;\n      }\n    },\n    _expandIfNotCollapsed: function _expandIfNotCollapsed() {\n      return this._map && !this.options.collapsed && this.expand(), this;\n    },\n    _expand: function _expand() {\n      return this.expand();\n    },\n    _collapse: function _collapse() {\n      return this.collapse();\n    }\n  }),\n      Ce = Te.extend({\n    options: {\n      position: \"topleft\",\n      zoomInText: \"+\",\n      zoomInTitle: \"Zoom in\",\n      zoomOutText: \"&#x2212;\",\n      zoomOutTitle: \"Zoom out\"\n    },\n    onAdd: function onAdd(t) {\n      var i = \"leaflet-control-zoom\",\n          e = G(\"div\", i + \" leaflet-bar\"),\n          n = this.options;\n      return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, i + \"-in\", e, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, i + \"-out\", e, this._zoomOut), this._updateDisabled(), t.on(\"zoomend zoomlevelschange\", this._updateDisabled, this), e;\n    },\n    onRemove: function onRemove(t) {\n      t.off(\"zoomend zoomlevelschange\", this._updateDisabled, this);\n    },\n    disable: function disable() {\n      return this._disabled = !0, this._updateDisabled(), this;\n    },\n    enable: function enable() {\n      return this._disabled = !1, this._updateDisabled(), this;\n    },\n    _zoomIn: function _zoomIn(t) {\n      !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));\n    },\n    _zoomOut: function _zoomOut(t) {\n      !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1));\n    },\n    _createButton: function _createButton(t, i, e, n, o) {\n      var s = G(\"a\", e, n);\n      return s.innerHTML = t, s.href = \"#\", s.title = i, s.setAttribute(\"role\", \"button\"), s.setAttribute(\"aria-label\", i), wt(s), mt(s, \"click\", Lt), mt(s, \"click\", o, this), mt(s, \"click\", this._refocusOnMap, this), s;\n    },\n    _updateDisabled: function _updateDisabled() {\n      var t = this._map,\n          i = \"leaflet-disabled\";\n      tt(this._zoomInButton, i), tt(this._zoomOutButton, i), (this._disabled || t._zoom === t.getMinZoom()) && Q(this._zoomOutButton, i), (this._disabled || t._zoom === t.getMaxZoom()) && Q(this._zoomInButton, i);\n    }\n  });\n  be.mergeOptions({\n    zoomControl: !0\n  }), be.addInitHook(function () {\n    this.options.zoomControl && (this.zoomControl = new Ce(), this.addControl(this.zoomControl));\n  });\n  var Se = Te.extend({\n    options: {\n      position: \"bottomleft\",\n      maxWidth: 100,\n      metric: !0,\n      imperial: !0\n    },\n    onAdd: function onAdd(t) {\n      var i = G(\"div\", \"leaflet-control-scale\"),\n          e = this.options;\n      return this._addScales(e, \"leaflet-control-scale-line\", i), t.on(e.updateWhenIdle ? \"moveend\" : \"move\", this._update, this), t.whenReady(this._update, this), i;\n    },\n    onRemove: function onRemove(t) {\n      t.off(this.options.updateWhenIdle ? \"moveend\" : \"move\", this._update, this);\n    },\n    _addScales: function _addScales(t, i, e) {\n      t.metric && (this._mScale = G(\"div\", i, e)), t.imperial && (this._iScale = G(\"div\", i, e));\n    },\n    _update: function _update() {\n      var t = this._map,\n          i = t.getSize().y / 2,\n          e = t.distance(t.containerPointToLatLng([0, i]), t.containerPointToLatLng([this.options.maxWidth, i]));\n\n      this._updateScales(e);\n    },\n    _updateScales: function _updateScales(t) {\n      this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t);\n    },\n    _updateMetric: function _updateMetric(t) {\n      var i = this._getRoundNum(t),\n          e = i < 1e3 ? i + \" m\" : i / 1e3 + \" km\";\n\n      this._updateScale(this._mScale, e, i / t);\n    },\n    _updateImperial: function _updateImperial(t) {\n      var i,\n          e,\n          n,\n          o = 3.2808399 * t;\n      o > 5280 ? (i = o / 5280, e = this._getRoundNum(i), this._updateScale(this._iScale, e + \" mi\", e / i)) : (n = this._getRoundNum(o), this._updateScale(this._iScale, n + \" ft\", n / o));\n    },\n    _updateScale: function _updateScale(t, i, e) {\n      t.style.width = Math.round(this.options.maxWidth * e) + \"px\", t.innerHTML = i;\n    },\n    _getRoundNum: function _getRoundNum(t) {\n      var i = Math.pow(10, (Math.floor(t) + \"\").length - 1),\n          e = t / i;\n      return e = e >= 10 ? 10 : e >= 5 ? 5 : e >= 3 ? 3 : e >= 2 ? 2 : 1, i * e;\n    }\n  }),\n      Ze = Te.extend({\n    options: {\n      position: \"bottomright\",\n      prefix: '<a href=\"http://leafletjs.com\" title=\"A JS library for interactive maps\">Leaflet</a>'\n    },\n    initialize: function initialize(t) {\n      l(this, t), this._attributions = {};\n    },\n    onAdd: function onAdd(t) {\n      t.attributionControl = this, this._container = G(\"div\", \"leaflet-control-attribution\"), wt(this._container);\n\n      for (var i in t._layers) {\n        t._layers[i].getAttribution && this.addAttribution(t._layers[i].getAttribution());\n      }\n\n      return this._update(), this._container;\n    },\n    setPrefix: function setPrefix(t) {\n      return this.options.prefix = t, this._update(), this;\n    },\n    addAttribution: function addAttribution(t) {\n      return t ? (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update(), this) : this;\n    },\n    removeAttribution: function removeAttribution(t) {\n      return t ? (this._attributions[t] && (this._attributions[t]--, this._update()), this) : this;\n    },\n    _update: function _update() {\n      if (this._map) {\n        var t = [];\n\n        for (var i in this._attributions) {\n          this._attributions[i] && t.push(i);\n        }\n\n        var e = [];\n        this.options.prefix && e.push(this.options.prefix), t.length && e.push(t.join(\", \")), this._container.innerHTML = e.join(\" | \");\n      }\n    }\n  });\n  be.mergeOptions({\n    attributionControl: !0\n  }), be.addInitHook(function () {\n    this.options.attributionControl && new Ze().addTo(this);\n  });\n  Te.Layers = Me, Te.Zoom = Ce, Te.Scale = Se, Te.Attribution = Ze, ze.layers = function (t, i, e) {\n    return new Me(t, i, e);\n  }, ze.zoom = function (t) {\n    return new Ce(t);\n  }, ze.scale = function (t) {\n    return new Se(t);\n  }, ze.attribution = function (t) {\n    return new Ze(t);\n  };\n  var Ee = v.extend({\n    initialize: function initialize(t) {\n      this._map = t;\n    },\n    enable: function enable() {\n      return this._enabled ? this : (this._enabled = !0, this.addHooks(), this);\n    },\n    disable: function disable() {\n      return this._enabled ? (this._enabled = !1, this.removeHooks(), this) : this;\n    },\n    enabled: function enabled() {\n      return !!this._enabled;\n    }\n  });\n\n  Ee.addTo = function (t, i) {\n    return t.addHandler(i, this), this;\n  };\n\n  var ke,\n      Be = {\n    Events: li\n  },\n      Ae = qi ? \"touchstart mousedown\" : \"mousedown\",\n      Ie = {\n    mousedown: \"mouseup\",\n    touchstart: \"touchend\",\n    pointerdown: \"touchend\",\n    MSPointerDown: \"touchend\"\n  },\n      Oe = {\n    mousedown: \"mousemove\",\n    touchstart: \"touchmove\",\n    pointerdown: \"touchmove\",\n    MSPointerDown: \"touchmove\"\n  },\n      Re = ci.extend({\n    options: {\n      clickTolerance: 3\n    },\n    initialize: function initialize(t, i, e, n) {\n      l(this, n), this._element = t, this._dragStartTarget = i || t, this._preventOutline = e;\n    },\n    enable: function enable() {\n      this._enabled || (mt(this._dragStartTarget, Ae, this._onDown, this), this._enabled = !0);\n    },\n    disable: function disable() {\n      this._enabled && (Re._dragging === this && this.finishDrag(), ft(this._dragStartTarget, Ae, this._onDown, this), this._enabled = !1, this._moved = !1);\n    },\n    _onDown: function _onDown(t) {\n      if (!t._simulated && this._enabled && (this._moved = !1, !$(this._element, \"leaflet-zoom-anim\") && !(Re._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || (Re._dragging = this, this._preventOutline && ct(this._element), ut(), fi(), this._moving)))) {\n        this.fire(\"down\");\n        var i = t.touches ? t.touches[0] : t,\n            e = dt(this._element);\n        this._startPoint = new x(i.clientX, i.clientY), this._parentScale = pt(e), mt(document, Oe[t.type], this._onMove, this), mt(document, Ie[t.type], this._onUp, this);\n      }\n    },\n    _onMove: function _onMove(t) {\n      if (!t._simulated && this._enabled) if (t.touches && t.touches.length > 1) this._moved = !0;else {\n        var i = t.touches && 1 === t.touches.length ? t.touches[0] : t,\n            e = new x(i.clientX, i.clientY)._subtract(this._startPoint);\n\n        (e.x || e.y) && (Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x, e.y /= this._parentScale.y, Pt(t), this._moved || (this.fire(\"dragstart\"), this._moved = !0, this._startPos = ht(this._element).subtract(e), Q(document.body, \"leaflet-dragging\"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), Q(this._lastTarget, \"leaflet-drag-target\")), this._newPos = this._startPos.add(e), this._moving = !0, g(this._animRequest), this._lastEvent = t, this._animRequest = f(this._updatePosition, this, !0)));\n      }\n    },\n    _updatePosition: function _updatePosition() {\n      var t = {\n        originalEvent: this._lastEvent\n      };\n      this.fire(\"predrag\", t), at(this._element, this._newPos), this.fire(\"drag\", t);\n    },\n    _onUp: function _onUp(t) {\n      !t._simulated && this._enabled && this.finishDrag();\n    },\n    finishDrag: function finishDrag() {\n      tt(document.body, \"leaflet-dragging\"), this._lastTarget && (tt(this._lastTarget, \"leaflet-drag-target\"), this._lastTarget = null);\n\n      for (var t in Oe) {\n        ft(document, Oe[t], this._onMove, this), ft(document, Ie[t], this._onUp, this);\n      }\n\n      lt(), gi(), this._moved && this._moving && (g(this._animRequest), this.fire(\"dragend\", {\n        distance: this._newPos.distanceTo(this._startPos)\n      })), this._moving = !1, Re._dragging = !1;\n    }\n  }),\n      Ne = (Object.freeze || Object)({\n    simplify: Zt,\n    pointToSegmentDistance: Et,\n    closestPointOnSegment: function closestPointOnSegment(t, i, e) {\n      return Dt(t, i, e);\n    },\n    clipSegment: It,\n    _getEdgeIntersection: Ot,\n    _getBitCode: Rt,\n    _sqClosestPointOnSegment: Dt,\n    isFlat: jt,\n    _flat: Wt\n  }),\n      De = (Object.freeze || Object)({\n    clipPolygon: Ht\n  }),\n      je = {\n    project: function project(t) {\n      return new x(t.lng, t.lat);\n    },\n    unproject: function unproject(t) {\n      return new M(t.y, t.x);\n    },\n    bounds: new P([-180, -90], [180, 90])\n  },\n      We = {\n    R: 6378137,\n    R_MINOR: 6356752.314245179,\n    bounds: new P([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),\n    project: function project(t) {\n      var i = Math.PI / 180,\n          e = this.R,\n          n = t.lat * i,\n          o = this.R_MINOR / e,\n          s = Math.sqrt(1 - o * o),\n          r = s * Math.sin(n),\n          a = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - r) / (1 + r), s / 2);\n      return n = -e * Math.log(Math.max(a, 1e-10)), new x(t.lng * i * e, n);\n    },\n    unproject: function unproject(t) {\n      for (var i, e = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, u = .1; h < 15 && Math.abs(u) > 1e-7; h++) {\n        i = s * Math.sin(a), i = Math.pow((1 - i) / (1 + i), s / 2), a += u = Math.PI / 2 - 2 * Math.atan(r * i) - a;\n      }\n\n      return new M(a * e, t.x * e / n);\n    }\n  },\n      He = (Object.freeze || Object)({\n    LonLat: je,\n    Mercator: We,\n    SphericalMercator: mi\n  }),\n      Fe = i({}, pi, {\n    code: \"EPSG:3395\",\n    projection: We,\n    transformation: function () {\n      var t = .5 / (Math.PI * We.R);\n      return Z(t, .5, -t, .5);\n    }()\n  }),\n      Ue = i({}, pi, {\n    code: \"EPSG:4326\",\n    projection: je,\n    transformation: Z(1 / 180, 1, -1 / 180, .5)\n  }),\n      Ve = i({}, di, {\n    projection: je,\n    transformation: Z(1, 0, -1, 0),\n    scale: function scale(t) {\n      return Math.pow(2, t);\n    },\n    zoom: function zoom(t) {\n      return Math.log(t) / Math.LN2;\n    },\n    distance: function distance(t, i) {\n      var e = i.lng - t.lng,\n          n = i.lat - t.lat;\n      return Math.sqrt(e * e + n * n);\n    },\n    infinite: !0\n  });\n  di.Earth = pi, di.EPSG3395 = Fe, di.EPSG3857 = yi, di.EPSG900913 = xi, di.EPSG4326 = Ue, di.Simple = Ve;\n  var qe = ci.extend({\n    options: {\n      pane: \"overlayPane\",\n      attribution: null,\n      bubblingMouseEvents: !0\n    },\n    addTo: function addTo(t) {\n      return t.addLayer(this), this;\n    },\n    remove: function remove() {\n      return this.removeFrom(this._map || this._mapToAdd);\n    },\n    removeFrom: function removeFrom(t) {\n      return t && t.removeLayer(this), this;\n    },\n    getPane: function getPane(t) {\n      return this._map.getPane(t ? this.options[t] || t : this.options.pane);\n    },\n    addInteractiveTarget: function addInteractiveTarget(t) {\n      return this._map._targets[n(t)] = this, this;\n    },\n    removeInteractiveTarget: function removeInteractiveTarget(t) {\n      return delete this._map._targets[n(t)], this;\n    },\n    getAttribution: function getAttribution() {\n      return this.options.attribution;\n    },\n    _layerAdd: function _layerAdd(t) {\n      var i = t.target;\n\n      if (i.hasLayer(this)) {\n        if (this._map = i, this._zoomAnimated = i._zoomAnimated, this.getEvents) {\n          var e = this.getEvents();\n          i.on(e, this), this.once(\"remove\", function () {\n            i.off(e, this);\n          }, this);\n        }\n\n        this.onAdd(i), this.getAttribution && i.attributionControl && i.attributionControl.addAttribution(this.getAttribution()), this.fire(\"add\"), i.fire(\"layeradd\", {\n          layer: this\n        });\n      }\n    }\n  });\n  be.include({\n    addLayer: function addLayer(t) {\n      if (!t._layerAdd) throw new Error(\"The provided object is not a Layer.\");\n      var i = n(t);\n      return this._layers[i] ? this : (this._layers[i] = t, t._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t), this);\n    },\n    removeLayer: function removeLayer(t) {\n      var i = n(t);\n      return this._layers[i] ? (this._loaded && t.onRemove(this), t.getAttribution && this.attributionControl && this.attributionControl.removeAttribution(t.getAttribution()), delete this._layers[i], this._loaded && (this.fire(\"layerremove\", {\n        layer: t\n      }), t.fire(\"remove\")), t._map = t._mapToAdd = null, this) : this;\n    },\n    hasLayer: function hasLayer(t) {\n      return !!t && n(t) in this._layers;\n    },\n    eachLayer: function eachLayer(t, i) {\n      for (var e in this._layers) {\n        t.call(i, this._layers[e]);\n      }\n\n      return this;\n    },\n    _addLayers: function _addLayers(t) {\n      for (var i = 0, e = (t = t ? oi(t) ? t : [t] : []).length; i < e; i++) {\n        this.addLayer(t[i]);\n      }\n    },\n    _addZoomLimit: function _addZoomLimit(t) {\n      !isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[n(t)] = t, this._updateZoomLevels());\n    },\n    _removeZoomLimit: function _removeZoomLimit(t) {\n      var i = n(t);\n      this._zoomBoundLayers[i] && (delete this._zoomBoundLayers[i], this._updateZoomLevels());\n    },\n    _updateZoomLevels: function _updateZoomLevels() {\n      var t = 1 / 0,\n          i = -1 / 0,\n          e = this._getZoomSpan();\n\n      for (var n in this._zoomBoundLayers) {\n        var o = this._zoomBoundLayers[n].options;\n        t = void 0 === o.minZoom ? t : Math.min(t, o.minZoom), i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom);\n      }\n\n      this._layersMaxZoom = i === -1 / 0 ? void 0 : i, this._layersMinZoom = t === 1 / 0 ? void 0 : t, e !== this._getZoomSpan() && this.fire(\"zoomlevelschange\"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom);\n    }\n  });\n  var Ge = qe.extend({\n    initialize: function initialize(t, i) {\n      l(this, i), this._layers = {};\n      var e, n;\n      if (t) for (e = 0, n = t.length; e < n; e++) {\n        this.addLayer(t[e]);\n      }\n    },\n    addLayer: function addLayer(t) {\n      var i = this.getLayerId(t);\n      return this._layers[i] = t, this._map && this._map.addLayer(t), this;\n    },\n    removeLayer: function removeLayer(t) {\n      var i = t in this._layers ? t : this.getLayerId(t);\n      return this._map && this._layers[i] && this._map.removeLayer(this._layers[i]), delete this._layers[i], this;\n    },\n    hasLayer: function hasLayer(t) {\n      return !!t && (t in this._layers || this.getLayerId(t) in this._layers);\n    },\n    clearLayers: function clearLayers() {\n      return this.eachLayer(this.removeLayer, this);\n    },\n    invoke: function invoke(t) {\n      var i,\n          e,\n          n = Array.prototype.slice.call(arguments, 1);\n\n      for (i in this._layers) {\n        (e = this._layers[i])[t] && e[t].apply(e, n);\n      }\n\n      return this;\n    },\n    onAdd: function onAdd(t) {\n      this.eachLayer(t.addLayer, t);\n    },\n    onRemove: function onRemove(t) {\n      this.eachLayer(t.removeLayer, t);\n    },\n    eachLayer: function eachLayer(t, i) {\n      for (var e in this._layers) {\n        t.call(i, this._layers[e]);\n      }\n\n      return this;\n    },\n    getLayer: function getLayer(t) {\n      return this._layers[t];\n    },\n    getLayers: function getLayers() {\n      var t = [];\n      return this.eachLayer(t.push, t), t;\n    },\n    setZIndex: function setZIndex(t) {\n      return this.invoke(\"setZIndex\", t);\n    },\n    getLayerId: function getLayerId(t) {\n      return n(t);\n    }\n  }),\n      Ke = Ge.extend({\n    addLayer: function addLayer(t) {\n      return this.hasLayer(t) ? this : (t.addEventParent(this), Ge.prototype.addLayer.call(this, t), this.fire(\"layeradd\", {\n        layer: t\n      }));\n    },\n    removeLayer: function removeLayer(t) {\n      return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]), t.removeEventParent(this), Ge.prototype.removeLayer.call(this, t), this.fire(\"layerremove\", {\n        layer: t\n      })) : this;\n    },\n    setStyle: function setStyle(t) {\n      return this.invoke(\"setStyle\", t);\n    },\n    bringToFront: function bringToFront() {\n      return this.invoke(\"bringToFront\");\n    },\n    bringToBack: function bringToBack() {\n      return this.invoke(\"bringToBack\");\n    },\n    getBounds: function getBounds() {\n      var t = new T();\n\n      for (var i in this._layers) {\n        var e = this._layers[i];\n        t.extend(e.getBounds ? e.getBounds() : e.getLatLng());\n      }\n\n      return t;\n    }\n  }),\n      Ye = v.extend({\n    options: {\n      popupAnchor: [0, 0],\n      tooltipAnchor: [0, 0]\n    },\n    initialize: function initialize(t) {\n      l(this, t);\n    },\n    createIcon: function createIcon(t) {\n      return this._createIcon(\"icon\", t);\n    },\n    createShadow: function createShadow(t) {\n      return this._createIcon(\"shadow\", t);\n    },\n    _createIcon: function _createIcon(t, i) {\n      var e = this._getIconUrl(t);\n\n      if (!e) {\n        if (\"icon\" === t) throw new Error(\"iconUrl not set in Icon options (see the docs).\");\n        return null;\n      }\n\n      var n = this._createImg(e, i && \"IMG\" === i.tagName ? i : null);\n\n      return this._setIconStyles(n, t), n;\n    },\n    _setIconStyles: function _setIconStyles(t, i) {\n      var e = this.options,\n          n = e[i + \"Size\"];\n      \"number\" == typeof n && (n = [n, n]);\n      var o = w(n),\n          s = w(\"shadow\" === i && e.shadowAnchor || e.iconAnchor || o && o.divideBy(2, !0));\n      t.className = \"leaflet-marker-\" + i + \" \" + (e.className || \"\"), s && (t.style.marginLeft = -s.x + \"px\", t.style.marginTop = -s.y + \"px\"), o && (t.style.width = o.x + \"px\", t.style.height = o.y + \"px\");\n    },\n    _createImg: function _createImg(t, i) {\n      return i = i || document.createElement(\"img\"), i.src = t, i;\n    },\n    _getIconUrl: function _getIconUrl(t) {\n      return Yi && this.options[t + \"RetinaUrl\"] || this.options[t + \"Url\"];\n    }\n  }),\n      Xe = Ye.extend({\n    options: {\n      iconUrl: \"marker-icon.png\",\n      iconRetinaUrl: \"marker-icon-2x.png\",\n      shadowUrl: \"marker-shadow.png\",\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      tooltipAnchor: [16, -28],\n      shadowSize: [41, 41]\n    },\n    _getIconUrl: function _getIconUrl(t) {\n      return Xe.imagePath || (Xe.imagePath = this._detectIconPath()), (this.options.imagePath || Xe.imagePath) + Ye.prototype._getIconUrl.call(this, t);\n    },\n    _detectIconPath: function _detectIconPath() {\n      var t = G(\"div\", \"leaflet-default-icon-path\", document.body),\n          i = q(t, \"background-image\") || q(t, \"backgroundImage\");\n      return document.body.removeChild(t), i = null === i || 0 !== i.indexOf(\"url\") ? \"\" : i.replace(/^url\\([\"']?/, \"\").replace(/marker-icon\\.png[\"']?\\)$/, \"\");\n    }\n  }),\n      Je = Ee.extend({\n    initialize: function initialize(t) {\n      this._marker = t;\n    },\n    addHooks: function addHooks() {\n      var t = this._marker._icon;\n      this._draggable || (this._draggable = new Re(t, t, !0)), this._draggable.on({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).enable(), Q(t, \"leaflet-marker-draggable\");\n    },\n    removeHooks: function removeHooks() {\n      this._draggable.off({\n        dragstart: this._onDragStart,\n        predrag: this._onPreDrag,\n        drag: this._onDrag,\n        dragend: this._onDragEnd\n      }, this).disable(), this._marker._icon && tt(this._marker._icon, \"leaflet-marker-draggable\");\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    _adjustPan: function _adjustPan(t) {\n      var i = this._marker,\n          e = i._map,\n          n = this._marker.options.autoPanSpeed,\n          o = this._marker.options.autoPanPadding,\n          s = ht(i._icon),\n          r = e.getPixelBounds(),\n          a = e.getPixelOrigin(),\n          h = b(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o));\n\n      if (!h.contains(s)) {\n        var u = w((Math.max(h.max.x, s.x) - h.max.x) / (r.max.x - h.max.x) - (Math.min(h.min.x, s.x) - h.min.x) / (r.min.x - h.min.x), (Math.max(h.max.y, s.y) - h.max.y) / (r.max.y - h.max.y) - (Math.min(h.min.y, s.y) - h.min.y) / (r.min.y - h.min.y)).multiplyBy(n);\n        e.panBy(u, {\n          animate: !1\n        }), this._draggable._newPos._add(u), this._draggable._startPos._add(u), at(i._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = f(this._adjustPan.bind(this, t));\n      }\n    },\n    _onDragStart: function _onDragStart() {\n      this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup().fire(\"movestart\").fire(\"dragstart\");\n    },\n    _onPreDrag: function _onPreDrag(t) {\n      this._marker.options.autoPan && (g(this._panRequest), this._panRequest = f(this._adjustPan.bind(this, t)));\n    },\n    _onDrag: function _onDrag(t) {\n      var i = this._marker,\n          e = i._shadow,\n          n = ht(i._icon),\n          o = i._map.layerPointToLatLng(n);\n\n      e && at(e, n), i._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, i.fire(\"move\", t).fire(\"drag\", t);\n    },\n    _onDragEnd: function _onDragEnd(t) {\n      g(this._panRequest), delete this._oldLatLng, this._marker.fire(\"moveend\").fire(\"dragend\", t);\n    }\n  }),\n      $e = qe.extend({\n    options: {\n      icon: new Xe(),\n      interactive: !0,\n      keyboard: !0,\n      title: \"\",\n      alt: \"\",\n      zIndexOffset: 0,\n      opacity: 1,\n      riseOnHover: !1,\n      riseOffset: 250,\n      pane: \"markerPane\",\n      bubblingMouseEvents: !1,\n      draggable: !1,\n      autoPan: !1,\n      autoPanPadding: [50, 50],\n      autoPanSpeed: 10\n    },\n    initialize: function initialize(t, i) {\n      l(this, i), this._latlng = C(t);\n    },\n    onAdd: function onAdd(t) {\n      this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on(\"zoomanim\", this._animateZoom, this), this._initIcon(), this.update();\n    },\n    onRemove: function onRemove(t) {\n      this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off(\"zoomanim\", this._animateZoom, this), this._removeIcon(), this._removeShadow();\n    },\n    getEvents: function getEvents() {\n      return {\n        zoom: this.update,\n        viewreset: this.update\n      };\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(t) {\n      var i = this._latlng;\n      return this._latlng = C(t), this.update(), this.fire(\"move\", {\n        oldLatLng: i,\n        latlng: this._latlng\n      });\n    },\n    setZIndexOffset: function setZIndexOffset(t) {\n      return this.options.zIndexOffset = t, this.update();\n    },\n    setIcon: function setIcon(t) {\n      return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this;\n    },\n    getElement: function getElement() {\n      return this._icon;\n    },\n    update: function update() {\n      if (this._icon && this._map) {\n        var t = this._map.latLngToLayerPoint(this._latlng).round();\n\n        this._setPos(t);\n      }\n\n      return this;\n    },\n    _initIcon: function _initIcon() {\n      var t = this.options,\n          i = \"leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\"),\n          e = t.icon.createIcon(this._icon),\n          n = !1;\n      e !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (e.title = t.title), \"IMG\" === e.tagName && (e.alt = t.alt || \"\")), Q(e, i), t.keyboard && (e.tabIndex = \"0\"), this._icon = e, t.riseOnHover && this.on({\n        mouseover: this._bringToFront,\n        mouseout: this._resetZIndex\n      });\n      var o = t.icon.createShadow(this._shadow),\n          s = !1;\n      o !== this._shadow && (this._removeShadow(), s = !0), o && (Q(o, i), o.alt = \"\"), this._shadow = o, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), o && s && this.getPane(\"shadowPane\").appendChild(this._shadow);\n    },\n    _removeIcon: function _removeIcon() {\n      this.options.riseOnHover && this.off({\n        mouseover: this._bringToFront,\n        mouseout: this._resetZIndex\n      }), K(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null;\n    },\n    _removeShadow: function _removeShadow() {\n      this._shadow && K(this._shadow), this._shadow = null;\n    },\n    _setPos: function _setPos(t) {\n      at(this._icon, t), this._shadow && at(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex();\n    },\n    _updateZIndex: function _updateZIndex(t) {\n      this._icon.style.zIndex = this._zIndex + t;\n    },\n    _animateZoom: function _animateZoom(t) {\n      var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();\n\n      this._setPos(i);\n    },\n    _initInteraction: function _initInteraction() {\n      if (this.options.interactive && (Q(this._icon, \"leaflet-interactive\"), this.addInteractiveTarget(this._icon), Je)) {\n        var t = this.options.draggable;\n        this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new Je(this), t && this.dragging.enable();\n      }\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._map && this._updateOpacity(), this;\n    },\n    _updateOpacity: function _updateOpacity() {\n      var t = this.options.opacity;\n      nt(this._icon, t), this._shadow && nt(this._shadow, t);\n    },\n    _bringToFront: function _bringToFront() {\n      this._updateZIndex(this.options.riseOffset);\n    },\n    _resetZIndex: function _resetZIndex() {\n      this._updateZIndex(0);\n    },\n    _getPopupAnchor: function _getPopupAnchor() {\n      return this.options.icon.options.popupAnchor;\n    },\n    _getTooltipAnchor: function _getTooltipAnchor() {\n      return this.options.icon.options.tooltipAnchor;\n    }\n  }),\n      Qe = qe.extend({\n    options: {\n      stroke: !0,\n      color: \"#3388ff\",\n      weight: 3,\n      opacity: 1,\n      lineCap: \"round\",\n      lineJoin: \"round\",\n      dashArray: null,\n      dashOffset: null,\n      fill: !1,\n      fillColor: null,\n      fillOpacity: .2,\n      fillRule: \"evenodd\",\n      interactive: !0,\n      bubblingMouseEvents: !0\n    },\n    beforeAdd: function beforeAdd(t) {\n      this._renderer = t.getRenderer(this);\n    },\n    onAdd: function onAdd() {\n      this._renderer._initPath(this), this._reset(), this._renderer._addPath(this);\n    },\n    onRemove: function onRemove() {\n      this._renderer._removePath(this);\n    },\n    redraw: function redraw() {\n      return this._map && this._renderer._updatePath(this), this;\n    },\n    setStyle: function setStyle(t) {\n      return l(this, t), this._renderer && this._renderer._updateStyle(this), this;\n    },\n    bringToFront: function bringToFront() {\n      return this._renderer && this._renderer._bringToFront(this), this;\n    },\n    bringToBack: function bringToBack() {\n      return this._renderer && this._renderer._bringToBack(this), this;\n    },\n    getElement: function getElement() {\n      return this._path;\n    },\n    _reset: function _reset() {\n      this._project(), this._update();\n    },\n    _clickTolerance: function _clickTolerance() {\n      return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;\n    }\n  }),\n      tn = Qe.extend({\n    options: {\n      fill: !0,\n      radius: 10\n    },\n    initialize: function initialize(t, i) {\n      l(this, i), this._latlng = C(t), this._radius = this.options.radius;\n    },\n    setLatLng: function setLatLng(t) {\n      return this._latlng = C(t), this.redraw(), this.fire(\"move\", {\n        latlng: this._latlng\n      });\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setRadius: function setRadius(t) {\n      return this.options.radius = this._radius = t, this.redraw();\n    },\n    getRadius: function getRadius() {\n      return this._radius;\n    },\n    setStyle: function setStyle(t) {\n      var i = t && t.radius || this._radius;\n      return Qe.prototype.setStyle.call(this, t), this.setRadius(i), this;\n    },\n    _project: function _project() {\n      this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds();\n    },\n    _updateBounds: function _updateBounds() {\n      var t = this._radius,\n          i = this._radiusY || t,\n          e = this._clickTolerance(),\n          n = [t + e, i + e];\n\n      this._pxBounds = new P(this._point.subtract(n), this._point.add(n));\n    },\n    _update: function _update() {\n      this._map && this._updatePath();\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updateCircle(this);\n    },\n    _empty: function _empty() {\n      return this._radius && !this._renderer._bounds.intersects(this._pxBounds);\n    },\n    _containsPoint: function _containsPoint(t) {\n      return t.distanceTo(this._point) <= this._radius + this._clickTolerance();\n    }\n  }),\n      en = tn.extend({\n    initialize: function initialize(t, e, n) {\n      if (\"number\" == typeof e && (e = i({}, n, {\n        radius: e\n      })), l(this, e), this._latlng = C(t), isNaN(this.options.radius)) throw new Error(\"Circle radius cannot be NaN\");\n      this._mRadius = this.options.radius;\n    },\n    setRadius: function setRadius(t) {\n      return this._mRadius = t, this.redraw();\n    },\n    getRadius: function getRadius() {\n      return this._mRadius;\n    },\n    getBounds: function getBounds() {\n      var t = [this._radius, this._radiusY || this._radius];\n      return new T(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t)));\n    },\n    setStyle: Qe.prototype.setStyle,\n    _project: function _project() {\n      var t = this._latlng.lng,\n          i = this._latlng.lat,\n          e = this._map,\n          n = e.options.crs;\n\n      if (n.distance === pi.distance) {\n        var o = Math.PI / 180,\n            s = this._mRadius / pi.R / o,\n            r = e.project([i + s, t]),\n            a = e.project([i - s, t]),\n            h = r.add(a).divideBy(2),\n            u = e.unproject(h).lat,\n            l = Math.acos((Math.cos(s * o) - Math.sin(i * o) * Math.sin(u * o)) / (Math.cos(i * o) * Math.cos(u * o))) / o;\n        (isNaN(l) || 0 === l) && (l = s / Math.cos(Math.PI / 180 * i)), this._point = h.subtract(e.getPixelOrigin()), this._radius = isNaN(l) ? 0 : h.x - e.project([u, t - l]).x, this._radiusY = h.y - r.y;\n      } else {\n        var c = n.unproject(n.project(this._latlng).subtract([this._mRadius, 0]));\n        this._point = e.latLngToLayerPoint(this._latlng), this._radius = this._point.x - e.latLngToLayerPoint(c).x;\n      }\n\n      this._updateBounds();\n    }\n  }),\n      nn = Qe.extend({\n    options: {\n      smoothFactor: 1,\n      noClip: !1\n    },\n    initialize: function initialize(t, i) {\n      l(this, i), this._setLatLngs(t);\n    },\n    getLatLngs: function getLatLngs() {\n      return this._latlngs;\n    },\n    setLatLngs: function setLatLngs(t) {\n      return this._setLatLngs(t), this.redraw();\n    },\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length;\n    },\n    closestLayerPoint: function closestLayerPoint(t) {\n      for (var i, e, n = 1 / 0, o = null, s = Dt, r = 0, a = this._parts.length; r < a; r++) {\n        for (var h = this._parts[r], u = 1, l = h.length; u < l; u++) {\n          var c = s(t, i = h[u - 1], e = h[u], !0);\n          c < n && (n = c, o = s(t, i, e));\n        }\n      }\n\n      return o && (o.distance = Math.sqrt(n)), o;\n    },\n    getCenter: function getCenter() {\n      if (!this._map) throw new Error(\"Must add layer to map before using getCenter()\");\n      var t,\n          i,\n          e,\n          n,\n          o,\n          s,\n          r,\n          a = this._rings[0],\n          h = a.length;\n      if (!h) return null;\n\n      for (t = 0, i = 0; t < h - 1; t++) {\n        i += a[t].distanceTo(a[t + 1]) / 2;\n      }\n\n      if (0 === i) return this._map.layerPointToLatLng(a[0]);\n\n      for (t = 0, n = 0; t < h - 1; t++) {\n        if (o = a[t], s = a[t + 1], e = o.distanceTo(s), (n += e) > i) return r = (n - i) / e, this._map.layerPointToLatLng([s.x - r * (s.x - o.x), s.y - r * (s.y - o.y)]);\n      }\n    },\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    addLatLng: function addLatLng(t, i) {\n      return i = i || this._defaultShape(), t = C(t), i.push(t), this._bounds.extend(t), this.redraw();\n    },\n    _setLatLngs: function _setLatLngs(t) {\n      this._bounds = new T(), this._latlngs = this._convertLatLngs(t);\n    },\n    _defaultShape: function _defaultShape() {\n      return jt(this._latlngs) ? this._latlngs : this._latlngs[0];\n    },\n    _convertLatLngs: function _convertLatLngs(t) {\n      for (var i = [], e = jt(t), n = 0, o = t.length; n < o; n++) {\n        e ? (i[n] = C(t[n]), this._bounds.extend(i[n])) : i[n] = this._convertLatLngs(t[n]);\n      }\n\n      return i;\n    },\n    _project: function _project() {\n      var t = new P();\n      this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t);\n\n      var i = this._clickTolerance(),\n          e = new x(i, i);\n\n      this._bounds.isValid() && t.isValid() && (t.min._subtract(e), t.max._add(e), this._pxBounds = t);\n    },\n    _projectLatlngs: function _projectLatlngs(t, i, e) {\n      var n,\n          o,\n          s = t[0] instanceof M,\n          r = t.length;\n\n      if (s) {\n        for (o = [], n = 0; n < r; n++) {\n          o[n] = this._map.latLngToLayerPoint(t[n]), e.extend(o[n]);\n        }\n\n        i.push(o);\n      } else for (n = 0; n < r; n++) {\n        this._projectLatlngs(t[n], i, e);\n      }\n    },\n    _clipPoints: function _clipPoints() {\n      var t = this._renderer._bounds;\n      if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings;else {\n        var i,\n            e,\n            n,\n            o,\n            s,\n            r,\n            a,\n            h = this._parts;\n\n        for (i = 0, n = 0, o = this._rings.length; i < o; i++) {\n          for (e = 0, s = (a = this._rings[i]).length; e < s - 1; e++) {\n            (r = It(a[e], a[e + 1], t, e, !0)) && (h[n] = h[n] || [], h[n].push(r[0]), r[1] === a[e + 1] && e !== s - 2 || (h[n].push(r[1]), n++));\n          }\n        }\n      }\n    },\n    _simplifyPoints: function _simplifyPoints() {\n      for (var t = this._parts, i = this.options.smoothFactor, e = 0, n = t.length; e < n; e++) {\n        t[e] = Zt(t[e], i);\n      }\n    },\n    _update: function _update() {\n      this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath());\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this);\n    },\n    _containsPoint: function _containsPoint(t, i) {\n      var e,\n          n,\n          o,\n          s,\n          r,\n          a,\n          h = this._clickTolerance();\n\n      if (!this._pxBounds || !this._pxBounds.contains(t)) return !1;\n\n      for (e = 0, s = this._parts.length; e < s; e++) {\n        for (n = 0, o = (r = (a = this._parts[e]).length) - 1; n < r; o = n++) {\n          if ((i || 0 !== n) && Et(t, a[o], a[n]) <= h) return !0;\n        }\n      }\n\n      return !1;\n    }\n  });\n  nn._flat = Wt;\n  var on = nn.extend({\n    options: {\n      fill: !0\n    },\n    isEmpty: function isEmpty() {\n      return !this._latlngs.length || !this._latlngs[0].length;\n    },\n    getCenter: function getCenter() {\n      if (!this._map) throw new Error(\"Must add layer to map before using getCenter()\");\n      var t,\n          i,\n          e,\n          n,\n          o,\n          s,\n          r,\n          a,\n          h,\n          u = this._rings[0],\n          l = u.length;\n      if (!l) return null;\n\n      for (s = r = a = 0, t = 0, i = l - 1; t < l; i = t++) {\n        e = u[t], n = u[i], o = e.y * n.x - n.y * e.x, r += (e.x + n.x) * o, a += (e.y + n.y) * o, s += 3 * o;\n      }\n\n      return h = 0 === s ? u[0] : [r / s, a / s], this._map.layerPointToLatLng(h);\n    },\n    _convertLatLngs: function _convertLatLngs(t) {\n      var i = nn.prototype._convertLatLngs.call(this, t),\n          e = i.length;\n\n      return e >= 2 && i[0] instanceof M && i[0].equals(i[e - 1]) && i.pop(), i;\n    },\n    _setLatLngs: function _setLatLngs(t) {\n      nn.prototype._setLatLngs.call(this, t), jt(this._latlngs) && (this._latlngs = [this._latlngs]);\n    },\n    _defaultShape: function _defaultShape() {\n      return jt(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];\n    },\n    _clipPoints: function _clipPoints() {\n      var t = this._renderer._bounds,\n          i = this.options.weight,\n          e = new x(i, i);\n      if (t = new P(t.min.subtract(e), t.max.add(e)), this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings;else for (var n, o = 0, s = this._rings.length; o < s; o++) {\n        (n = Ht(this._rings[o], t, !0)).length && this._parts.push(n);\n      }\n    },\n    _updatePath: function _updatePath() {\n      this._renderer._updatePoly(this, !0);\n    },\n    _containsPoint: function _containsPoint(t) {\n      var i,\n          e,\n          n,\n          o,\n          s,\n          r,\n          a,\n          h,\n          u = !1;\n      if (!this._pxBounds || !this._pxBounds.contains(t)) return !1;\n\n      for (o = 0, a = this._parts.length; o < a; o++) {\n        for (s = 0, r = (h = (i = this._parts[o]).length) - 1; s < h; r = s++) {\n          e = i[s], n = i[r], e.y > t.y != n.y > t.y && t.x < (n.x - e.x) * (t.y - e.y) / (n.y - e.y) + e.x && (u = !u);\n        }\n      }\n\n      return u || nn.prototype._containsPoint.call(this, t, !0);\n    }\n  }),\n      sn = Ke.extend({\n    initialize: function initialize(t, i) {\n      l(this, i), this._layers = {}, t && this.addData(t);\n    },\n    addData: function addData(t) {\n      var i,\n          e,\n          n,\n          o = oi(t) ? t : t.features;\n\n      if (o) {\n        for (i = 0, e = o.length; i < e; i++) {\n          ((n = o[i]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n);\n        }\n\n        return this;\n      }\n\n      var s = this.options;\n      if (s.filter && !s.filter(t)) return this;\n      var r = Ft(t, s);\n      return r ? (r.feature = Yt(t), r.defaultOptions = r.options, this.resetStyle(r), s.onEachFeature && s.onEachFeature(t, r), this.addLayer(r)) : this;\n    },\n    resetStyle: function resetStyle(t) {\n      return t.options = i({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this;\n    },\n    setStyle: function setStyle(t) {\n      return this.eachLayer(function (i) {\n        this._setLayerStyle(i, t);\n      }, this);\n    },\n    _setLayerStyle: function _setLayerStyle(t, i) {\n      \"function\" == typeof i && (i = i(t.feature)), t.setStyle && t.setStyle(i);\n    }\n  }),\n      rn = {\n    toGeoJSON: function toGeoJSON(t) {\n      return Kt(this, {\n        type: \"Point\",\n        coordinates: qt(this.getLatLng(), t)\n      });\n    }\n  };\n  $e.include(rn), en.include(rn), tn.include(rn), nn.include({\n    toGeoJSON: function toGeoJSON(t) {\n      var i = !jt(this._latlngs),\n          e = Gt(this._latlngs, i ? 1 : 0, !1, t);\n      return Kt(this, {\n        type: (i ? \"Multi\" : \"\") + \"LineString\",\n        coordinates: e\n      });\n    }\n  }), on.include({\n    toGeoJSON: function toGeoJSON(t) {\n      var i = !jt(this._latlngs),\n          e = i && !jt(this._latlngs[0]),\n          n = Gt(this._latlngs, e ? 2 : i ? 1 : 0, !0, t);\n      return i || (n = [n]), Kt(this, {\n        type: (e ? \"Multi\" : \"\") + \"Polygon\",\n        coordinates: n\n      });\n    }\n  }), Ge.include({\n    toMultiPoint: function toMultiPoint(t) {\n      var i = [];\n      return this.eachLayer(function (e) {\n        i.push(e.toGeoJSON(t).geometry.coordinates);\n      }), Kt(this, {\n        type: \"MultiPoint\",\n        coordinates: i\n      });\n    },\n    toGeoJSON: function toGeoJSON(t) {\n      var i = this.feature && this.feature.geometry && this.feature.geometry.type;\n      if (\"MultiPoint\" === i) return this.toMultiPoint(t);\n      var e = \"GeometryCollection\" === i,\n          n = [];\n      return this.eachLayer(function (i) {\n        if (i.toGeoJSON) {\n          var o = i.toGeoJSON(t);\n          if (e) n.push(o.geometry);else {\n            var s = Yt(o);\n            \"FeatureCollection\" === s.type ? n.push.apply(n, s.features) : n.push(s);\n          }\n        }\n      }), e ? Kt(this, {\n        geometries: n,\n        type: \"GeometryCollection\"\n      }) : {\n        type: \"FeatureCollection\",\n        features: n\n      };\n    }\n  });\n  var an = Xt,\n      hn = qe.extend({\n    options: {\n      opacity: 1,\n      alt: \"\",\n      interactive: !1,\n      crossOrigin: !1,\n      errorOverlayUrl: \"\",\n      zIndex: 1,\n      className: \"\"\n    },\n    initialize: function initialize(t, i, e) {\n      this._url = t, this._bounds = z(i), l(this, e);\n    },\n    onAdd: function onAdd() {\n      this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (Q(this._image, \"leaflet-interactive\"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset();\n    },\n    onRemove: function onRemove() {\n      K(this._image), this.options.interactive && this.removeInteractiveTarget(this._image);\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._image && this._updateOpacity(), this;\n    },\n    setStyle: function setStyle(t) {\n      return t.opacity && this.setOpacity(t.opacity), this;\n    },\n    bringToFront: function bringToFront() {\n      return this._map && X(this._image), this;\n    },\n    bringToBack: function bringToBack() {\n      return this._map && J(this._image), this;\n    },\n    setUrl: function setUrl(t) {\n      return this._url = t, this._image && (this._image.src = t), this;\n    },\n    setBounds: function setBounds(t) {\n      return this._bounds = z(t), this._map && this._reset(), this;\n    },\n    getEvents: function getEvents() {\n      var t = {\n        zoom: this._reset,\n        viewreset: this._reset\n      };\n      return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;\n    },\n    setZIndex: function setZIndex(t) {\n      return this.options.zIndex = t, this._updateZIndex(), this;\n    },\n    getBounds: function getBounds() {\n      return this._bounds;\n    },\n    getElement: function getElement() {\n      return this._image;\n    },\n    _initImage: function _initImage() {\n      var t = \"IMG\" === this._url.tagName,\n          i = this._image = t ? this._url : G(\"img\");\n      Q(i, \"leaflet-image-layer\"), this._zoomAnimated && Q(i, \"leaflet-zoom-animated\"), this.options.className && Q(i, this.options.className), i.onselectstart = r, i.onmousemove = r, i.onload = e(this.fire, this, \"load\"), i.onerror = e(this._overlayOnError, this, \"error\"), (this.options.crossOrigin || \"\" === this.options.crossOrigin) && (i.crossOrigin = !0 === this.options.crossOrigin ? \"\" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = i.src : (i.src = this._url, i.alt = this.options.alt);\n    },\n    _animateZoom: function _animateZoom(t) {\n      var i = this._map.getZoomScale(t.zoom),\n          e = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;\n\n      rt(this._image, e, i);\n    },\n    _reset: function _reset() {\n      var t = this._image,\n          i = new P(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())),\n          e = i.getSize();\n      at(t, i.min), t.style.width = e.x + \"px\", t.style.height = e.y + \"px\";\n    },\n    _updateOpacity: function _updateOpacity() {\n      nt(this._image, this.options.opacity);\n    },\n    _updateZIndex: function _updateZIndex() {\n      this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex);\n    },\n    _overlayOnError: function _overlayOnError() {\n      this.fire(\"error\");\n      var t = this.options.errorOverlayUrl;\n      t && this._url !== t && (this._url = t, this._image.src = t);\n    }\n  }),\n      un = hn.extend({\n    options: {\n      autoplay: !0,\n      loop: !0\n    },\n    _initImage: function _initImage() {\n      var t = \"VIDEO\" === this._url.tagName,\n          i = this._image = t ? this._url : G(\"video\");\n\n      if (Q(i, \"leaflet-image-layer\"), this._zoomAnimated && Q(i, \"leaflet-zoom-animated\"), i.onselectstart = r, i.onmousemove = r, i.onloadeddata = e(this.fire, this, \"load\"), t) {\n        for (var n = i.getElementsByTagName(\"source\"), o = [], s = 0; s < n.length; s++) {\n          o.push(n[s].src);\n        }\n\n        this._url = n.length > 0 ? o : [i.src];\n      } else {\n        oi(this._url) || (this._url = [this._url]), i.autoplay = !!this.options.autoplay, i.loop = !!this.options.loop;\n\n        for (var a = 0; a < this._url.length; a++) {\n          var h = G(\"source\");\n          h.src = this._url[a], i.appendChild(h);\n        }\n      }\n    }\n  }),\n      ln = qe.extend({\n    options: {\n      offset: [0, 7],\n      className: \"\",\n      pane: \"popupPane\"\n    },\n    initialize: function initialize(t, i) {\n      l(this, t), this._source = i;\n    },\n    onAdd: function onAdd(t) {\n      this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && nt(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && nt(this._container, 1), this.bringToFront();\n    },\n    onRemove: function onRemove(t) {\n      t._fadeAnimated ? (nt(this._container, 0), this._removeTimeout = setTimeout(e(K, void 0, this._container), 200)) : K(this._container);\n    },\n    getLatLng: function getLatLng() {\n      return this._latlng;\n    },\n    setLatLng: function setLatLng(t) {\n      return this._latlng = C(t), this._map && (this._updatePosition(), this._adjustPan()), this;\n    },\n    getContent: function getContent() {\n      return this._content;\n    },\n    setContent: function setContent(t) {\n      return this._content = t, this.update(), this;\n    },\n    getElement: function getElement() {\n      return this._container;\n    },\n    update: function update() {\n      this._map && (this._container.style.visibility = \"hidden\", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = \"\", this._adjustPan());\n    },\n    getEvents: function getEvents() {\n      var t = {\n        zoom: this._updatePosition,\n        viewreset: this._updatePosition\n      };\n      return this._zoomAnimated && (t.zoomanim = this._animateZoom), t;\n    },\n    isOpen: function isOpen() {\n      return !!this._map && this._map.hasLayer(this);\n    },\n    bringToFront: function bringToFront() {\n      return this._map && X(this._container), this;\n    },\n    bringToBack: function bringToBack() {\n      return this._map && J(this._container), this;\n    },\n    _updateContent: function _updateContent() {\n      if (this._content) {\n        var t = this._contentNode,\n            i = \"function\" == typeof this._content ? this._content(this._source || this) : this._content;\n        if (\"string\" == typeof i) t.innerHTML = i;else {\n          for (; t.hasChildNodes();) {\n            t.removeChild(t.firstChild);\n          }\n\n          t.appendChild(i);\n        }\n        this.fire(\"contentupdate\");\n      }\n    },\n    _updatePosition: function _updatePosition() {\n      if (this._map) {\n        var t = this._map.latLngToLayerPoint(this._latlng),\n            i = w(this.options.offset),\n            e = this._getAnchor();\n\n        this._zoomAnimated ? at(this._container, t.add(e)) : i = i.add(t).add(e);\n        var n = this._containerBottom = -i.y,\n            o = this._containerLeft = -Math.round(this._containerWidth / 2) + i.x;\n        this._container.style.bottom = n + \"px\", this._container.style.left = o + \"px\";\n      }\n    },\n    _getAnchor: function _getAnchor() {\n      return [0, 0];\n    }\n  }),\n      cn = ln.extend({\n    options: {\n      maxWidth: 300,\n      minWidth: 50,\n      maxHeight: null,\n      autoPan: !0,\n      autoPanPaddingTopLeft: null,\n      autoPanPaddingBottomRight: null,\n      autoPanPadding: [5, 5],\n      keepInView: !1,\n      closeButton: !0,\n      autoClose: !0,\n      closeOnEscapeKey: !0,\n      className: \"\"\n    },\n    openOn: function openOn(t) {\n      return t.openPopup(this), this;\n    },\n    onAdd: function onAdd(t) {\n      ln.prototype.onAdd.call(this, t), t.fire(\"popupopen\", {\n        popup: this\n      }), this._source && (this._source.fire(\"popupopen\", {\n        popup: this\n      }, !0), this._source instanceof Qe || this._source.on(\"preclick\", yt));\n    },\n    onRemove: function onRemove(t) {\n      ln.prototype.onRemove.call(this, t), t.fire(\"popupclose\", {\n        popup: this\n      }), this._source && (this._source.fire(\"popupclose\", {\n        popup: this\n      }, !0), this._source instanceof Qe || this._source.off(\"preclick\", yt));\n    },\n    getEvents: function getEvents() {\n      var t = ln.prototype.getEvents.call(this);\n      return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this._close), this.options.keepInView && (t.moveend = this._adjustPan), t;\n    },\n    _close: function _close() {\n      this._map && this._map.closePopup(this);\n    },\n    _initLayout: function _initLayout() {\n      var t = \"leaflet-popup\",\n          i = this._container = G(\"div\", t + \" \" + (this.options.className || \"\") + \" leaflet-zoom-animated\"),\n          e = this._wrapper = G(\"div\", t + \"-content-wrapper\", i);\n\n      if (this._contentNode = G(\"div\", t + \"-content\", e), wt(e), xt(this._contentNode), mt(e, \"contextmenu\", yt), this._tipContainer = G(\"div\", t + \"-tip-container\", i), this._tip = G(\"div\", t + \"-tip\", this._tipContainer), this.options.closeButton) {\n        var n = this._closeButton = G(\"a\", t + \"-close-button\", i);\n        n.href = \"#close\", n.innerHTML = \"&#215;\", mt(n, \"click\", this._onCloseButtonClick, this);\n      }\n    },\n    _updateLayout: function _updateLayout() {\n      var t = this._contentNode,\n          i = t.style;\n      i.width = \"\", i.whiteSpace = \"nowrap\";\n      var e = t.offsetWidth;\n      e = Math.min(e, this.options.maxWidth), e = Math.max(e, this.options.minWidth), i.width = e + 1 + \"px\", i.whiteSpace = \"\", i.height = \"\";\n      var n = t.offsetHeight,\n          o = this.options.maxHeight;\n      o && n > o ? (i.height = o + \"px\", Q(t, \"leaflet-popup-scrolled\")) : tt(t, \"leaflet-popup-scrolled\"), this._containerWidth = this._container.offsetWidth;\n    },\n    _animateZoom: function _animateZoom(t) {\n      var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center),\n          e = this._getAnchor();\n\n      at(this._container, i.add(e));\n    },\n    _adjustPan: function _adjustPan() {\n      if (this.options.autoPan) {\n        this._map._panAnim && this._map._panAnim.stop();\n        var t = this._map,\n            i = parseInt(q(this._container, \"marginBottom\"), 10) || 0,\n            e = this._container.offsetHeight + i,\n            n = this._containerWidth,\n            o = new x(this._containerLeft, -e - this._containerBottom);\n\n        o._add(ht(this._container));\n\n        var s = t.layerPointToContainerPoint(o),\n            r = w(this.options.autoPanPadding),\n            a = w(this.options.autoPanPaddingTopLeft || r),\n            h = w(this.options.autoPanPaddingBottomRight || r),\n            u = t.getSize(),\n            l = 0,\n            c = 0;\n        s.x + n + h.x > u.x && (l = s.x + n - u.x + h.x), s.x - l - a.x < 0 && (l = s.x - a.x), s.y + e + h.y > u.y && (c = s.y + e - u.y + h.y), s.y - c - a.y < 0 && (c = s.y - a.y), (l || c) && t.fire(\"autopanstart\").panBy([l, c]);\n      }\n    },\n    _onCloseButtonClick: function _onCloseButtonClick(t) {\n      this._close(), Lt(t);\n    },\n    _getAnchor: function _getAnchor() {\n      return w(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);\n    }\n  });\n  be.mergeOptions({\n    closePopupOnClick: !0\n  }), be.include({\n    openPopup: function openPopup(t, i, e) {\n      return t instanceof cn || (t = new cn(e).setContent(t)), i && t.setLatLng(i), this.hasLayer(t) ? this : (this._popup && this._popup.options.autoClose && this.closePopup(), this._popup = t, this.addLayer(t));\n    },\n    closePopup: function closePopup(t) {\n      return t && t !== this._popup || (t = this._popup, this._popup = null), t && this.removeLayer(t), this;\n    }\n  }), qe.include({\n    bindPopup: function bindPopup(t, i) {\n      return t instanceof cn ? (l(t, i), this._popup = t, t._source = this) : (this._popup && !i || (this._popup = new cn(i, this)), this._popup.setContent(t)), this._popupHandlersAdded || (this.on({\n        click: this._openPopup,\n        keypress: this._onKeyPress,\n        remove: this.closePopup,\n        move: this._movePopup\n      }), this._popupHandlersAdded = !0), this;\n    },\n    unbindPopup: function unbindPopup() {\n      return this._popup && (this.off({\n        click: this._openPopup,\n        keypress: this._onKeyPress,\n        remove: this.closePopup,\n        move: this._movePopup\n      }), this._popupHandlersAdded = !1, this._popup = null), this;\n    },\n    openPopup: function openPopup(t, i) {\n      if (t instanceof qe || (i = t, t = this), t instanceof Ke) for (var e in this._layers) {\n        t = this._layers[e];\n        break;\n      }\n      return i || (i = t.getCenter ? t.getCenter() : t.getLatLng()), this._popup && this._map && (this._popup._source = t, this._popup.update(), this._map.openPopup(this._popup, i)), this;\n    },\n    closePopup: function closePopup() {\n      return this._popup && this._popup._close(), this;\n    },\n    togglePopup: function togglePopup(t) {\n      return this._popup && (this._popup._map ? this.closePopup() : this.openPopup(t)), this;\n    },\n    isPopupOpen: function isPopupOpen() {\n      return !!this._popup && this._popup.isOpen();\n    },\n    setPopupContent: function setPopupContent(t) {\n      return this._popup && this._popup.setContent(t), this;\n    },\n    getPopup: function getPopup() {\n      return this._popup;\n    },\n    _openPopup: function _openPopup(t) {\n      var i = t.layer || t.target;\n      this._popup && this._map && (Lt(t), i instanceof Qe ? this.openPopup(t.layer || t.target, t.latlng) : this._map.hasLayer(this._popup) && this._popup._source === i ? this.closePopup() : this.openPopup(i, t.latlng));\n    },\n    _movePopup: function _movePopup(t) {\n      this._popup.setLatLng(t.latlng);\n    },\n    _onKeyPress: function _onKeyPress(t) {\n      13 === t.originalEvent.keyCode && this._openPopup(t);\n    }\n  });\n\n  var _n = ln.extend({\n    options: {\n      pane: \"tooltipPane\",\n      offset: [0, 0],\n      direction: \"auto\",\n      permanent: !1,\n      sticky: !1,\n      interactive: !1,\n      opacity: .9\n    },\n    onAdd: function onAdd(t) {\n      ln.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire(\"tooltipopen\", {\n        tooltip: this\n      }), this._source && this._source.fire(\"tooltipopen\", {\n        tooltip: this\n      }, !0);\n    },\n    onRemove: function onRemove(t) {\n      ln.prototype.onRemove.call(this, t), t.fire(\"tooltipclose\", {\n        tooltip: this\n      }), this._source && this._source.fire(\"tooltipclose\", {\n        tooltip: this\n      }, !0);\n    },\n    getEvents: function getEvents() {\n      var t = ln.prototype.getEvents.call(this);\n      return qi && !this.options.permanent && (t.preclick = this._close), t;\n    },\n    _close: function _close() {\n      this._map && this._map.closeTooltip(this);\n    },\n    _initLayout: function _initLayout() {\n      var t = \"leaflet-tooltip \" + (this.options.className || \"\") + \" leaflet-zoom-\" + (this._zoomAnimated ? \"animated\" : \"hide\");\n      this._contentNode = this._container = G(\"div\", t);\n    },\n    _updateLayout: function _updateLayout() {},\n    _adjustPan: function _adjustPan() {},\n    _setPosition: function _setPosition(t) {\n      var i = this._map,\n          e = this._container,\n          n = i.latLngToContainerPoint(i.getCenter()),\n          o = i.layerPointToContainerPoint(t),\n          s = this.options.direction,\n          r = e.offsetWidth,\n          a = e.offsetHeight,\n          h = w(this.options.offset),\n          u = this._getAnchor();\n\n      \"top\" === s ? t = t.add(w(-r / 2 + h.x, -a + h.y + u.y, !0)) : \"bottom\" === s ? t = t.subtract(w(r / 2 - h.x, -h.y, !0)) : \"center\" === s ? t = t.subtract(w(r / 2 + h.x, a / 2 - u.y + h.y, !0)) : \"right\" === s || \"auto\" === s && o.x < n.x ? (s = \"right\", t = t.add(w(h.x + u.x, u.y - a / 2 + h.y, !0))) : (s = \"left\", t = t.subtract(w(r + u.x - h.x, a / 2 - u.y - h.y, !0))), tt(e, \"leaflet-tooltip-right\"), tt(e, \"leaflet-tooltip-left\"), tt(e, \"leaflet-tooltip-top\"), tt(e, \"leaflet-tooltip-bottom\"), Q(e, \"leaflet-tooltip-\" + s), at(e, t);\n    },\n    _updatePosition: function _updatePosition() {\n      var t = this._map.latLngToLayerPoint(this._latlng);\n\n      this._setPosition(t);\n    },\n    setOpacity: function setOpacity(t) {\n      this.options.opacity = t, this._container && nt(this._container, t);\n    },\n    _animateZoom: function _animateZoom(t) {\n      var i = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);\n\n      this._setPosition(i);\n    },\n    _getAnchor: function _getAnchor() {\n      return w(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);\n    }\n  });\n\n  be.include({\n    openTooltip: function openTooltip(t, i, e) {\n      return t instanceof _n || (t = new _n(e).setContent(t)), i && t.setLatLng(i), this.hasLayer(t) ? this : this.addLayer(t);\n    },\n    closeTooltip: function closeTooltip(t) {\n      return t && this.removeLayer(t), this;\n    }\n  }), qe.include({\n    bindTooltip: function bindTooltip(t, i) {\n      return t instanceof _n ? (l(t, i), this._tooltip = t, t._source = this) : (this._tooltip && !i || (this._tooltip = new _n(i, this)), this._tooltip.setContent(t)), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this;\n    },\n    unbindTooltip: function unbindTooltip() {\n      return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this;\n    },\n    _initTooltipInteractions: function _initTooltipInteractions(t) {\n      if (t || !this._tooltipHandlersAdded) {\n        var i = t ? \"off\" : \"on\",\n            e = {\n          remove: this.closeTooltip,\n          move: this._moveTooltip\n        };\n        this._tooltip.options.permanent ? e.add = this._openTooltip : (e.mouseover = this._openTooltip, e.mouseout = this.closeTooltip, this._tooltip.options.sticky && (e.mousemove = this._moveTooltip), qi && (e.click = this._openTooltip)), this[i](e), this._tooltipHandlersAdded = !t;\n      }\n    },\n    openTooltip: function openTooltip(t, i) {\n      if (t instanceof qe || (i = t, t = this), t instanceof Ke) for (var e in this._layers) {\n        t = this._layers[e];\n        break;\n      }\n      return i || (i = t.getCenter ? t.getCenter() : t.getLatLng()), this._tooltip && this._map && (this._tooltip._source = t, this._tooltip.update(), this._map.openTooltip(this._tooltip, i), this._tooltip.options.interactive && this._tooltip._container && (Q(this._tooltip._container, \"leaflet-clickable\"), this.addInteractiveTarget(this._tooltip._container))), this;\n    },\n    closeTooltip: function closeTooltip() {\n      return this._tooltip && (this._tooltip._close(), this._tooltip.options.interactive && this._tooltip._container && (tt(this._tooltip._container, \"leaflet-clickable\"), this.removeInteractiveTarget(this._tooltip._container))), this;\n    },\n    toggleTooltip: function toggleTooltip(t) {\n      return this._tooltip && (this._tooltip._map ? this.closeTooltip() : this.openTooltip(t)), this;\n    },\n    isTooltipOpen: function isTooltipOpen() {\n      return this._tooltip.isOpen();\n    },\n    setTooltipContent: function setTooltipContent(t) {\n      return this._tooltip && this._tooltip.setContent(t), this;\n    },\n    getTooltip: function getTooltip() {\n      return this._tooltip;\n    },\n    _openTooltip: function _openTooltip(t) {\n      var i = t.layer || t.target;\n      this._tooltip && this._map && this.openTooltip(i, this._tooltip.options.sticky ? t.latlng : void 0);\n    },\n    _moveTooltip: function _moveTooltip(t) {\n      var i,\n          e,\n          n = t.latlng;\n      this._tooltip.options.sticky && t.originalEvent && (i = this._map.mouseEventToContainerPoint(t.originalEvent), e = this._map.containerPointToLayerPoint(i), n = this._map.layerPointToLatLng(e)), this._tooltip.setLatLng(n);\n    }\n  });\n  var dn = Ye.extend({\n    options: {\n      iconSize: [12, 12],\n      html: !1,\n      bgPos: null,\n      className: \"leaflet-div-icon\"\n    },\n    createIcon: function createIcon(t) {\n      var i = t && \"DIV\" === t.tagName ? t : document.createElement(\"div\"),\n          e = this.options;\n\n      if (i.innerHTML = !1 !== e.html ? e.html : \"\", e.bgPos) {\n        var n = w(e.bgPos);\n        i.style.backgroundPosition = -n.x + \"px \" + -n.y + \"px\";\n      }\n\n      return this._setIconStyles(i, \"icon\"), i;\n    },\n    createShadow: function createShadow() {\n      return null;\n    }\n  });\n  Ye.Default = Xe;\n  var pn = qe.extend({\n    options: {\n      tileSize: 256,\n      opacity: 1,\n      updateWhenIdle: Wi,\n      updateWhenZooming: !0,\n      updateInterval: 200,\n      zIndex: 1,\n      bounds: null,\n      minZoom: 0,\n      maxZoom: void 0,\n      maxNativeZoom: void 0,\n      minNativeZoom: void 0,\n      noWrap: !1,\n      pane: \"tilePane\",\n      className: \"\",\n      keepBuffer: 2\n    },\n    initialize: function initialize(t) {\n      l(this, t);\n    },\n    onAdd: function onAdd() {\n      this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView(), this._update();\n    },\n    beforeAdd: function beforeAdd(t) {\n      t._addZoomLimit(this);\n    },\n    onRemove: function onRemove(t) {\n      this._removeAllTiles(), K(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0;\n    },\n    bringToFront: function bringToFront() {\n      return this._map && (X(this._container), this._setAutoZIndex(Math.max)), this;\n    },\n    bringToBack: function bringToBack() {\n      return this._map && (J(this._container), this._setAutoZIndex(Math.min)), this;\n    },\n    getContainer: function getContainer() {\n      return this._container;\n    },\n    setOpacity: function setOpacity(t) {\n      return this.options.opacity = t, this._updateOpacity(), this;\n    },\n    setZIndex: function setZIndex(t) {\n      return this.options.zIndex = t, this._updateZIndex(), this;\n    },\n    isLoading: function isLoading() {\n      return this._loading;\n    },\n    redraw: function redraw() {\n      return this._map && (this._removeAllTiles(), this._update()), this;\n    },\n    getEvents: function getEvents() {\n      var t = {\n        viewprereset: this._invalidateAll,\n        viewreset: this._resetView,\n        zoom: this._resetView,\n        moveend: this._onMoveEnd\n      };\n      return this.options.updateWhenIdle || (this._onMove || (this._onMove = o(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t;\n    },\n    createTile: function createTile() {\n      return document.createElement(\"div\");\n    },\n    getTileSize: function getTileSize() {\n      var t = this.options.tileSize;\n      return t instanceof x ? t : new x(t, t);\n    },\n    _updateZIndex: function _updateZIndex() {\n      this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex);\n    },\n    _setAutoZIndex: function _setAutoZIndex(t) {\n      for (var i, e = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = e.length; o < s; o++) {\n        i = e[o].style.zIndex, e[o] !== this._container && i && (n = t(n, +i));\n      }\n\n      isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex());\n    },\n    _updateOpacity: function _updateOpacity() {\n      if (this._map && !Li) {\n        nt(this._container, this.options.opacity);\n        var t = +new Date(),\n            i = !1,\n            e = !1;\n\n        for (var n in this._tiles) {\n          var o = this._tiles[n];\n\n          if (o.current && o.loaded) {\n            var s = Math.min(1, (t - o.loaded) / 200);\n            nt(o.el, s), s < 1 ? i = !0 : (o.active ? e = !0 : this._onOpaqueTile(o), o.active = !0);\n          }\n        }\n\n        e && !this._noPrune && this._pruneTiles(), i && (g(this._fadeFrame), this._fadeFrame = f(this._updateOpacity, this));\n      }\n    },\n    _onOpaqueTile: r,\n    _initContainer: function _initContainer() {\n      this._container || (this._container = G(\"div\", \"leaflet-layer \" + (this.options.className || \"\")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container));\n    },\n    _updateLevels: function _updateLevels() {\n      var t = this._tileZoom,\n          i = this.options.maxZoom;\n\n      if (void 0 !== t) {\n        for (var e in this._levels) {\n          this._levels[e].el.children.length || e === t ? (this._levels[e].el.style.zIndex = i - Math.abs(t - e), this._onUpdateLevel(e)) : (K(this._levels[e].el), this._removeTilesAtZoom(e), this._onRemoveLevel(e), delete this._levels[e]);\n        }\n\n        var n = this._levels[t],\n            o = this._map;\n        return n || ((n = this._levels[t] = {}).el = G(\"div\", \"leaflet-tile-container leaflet-zoom-animated\", this._container), n.el.style.zIndex = i, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), n.el.offsetWidth, this._onCreateLevel(n)), this._level = n, n;\n      }\n    },\n    _onUpdateLevel: r,\n    _onRemoveLevel: r,\n    _onCreateLevel: r,\n    _pruneTiles: function _pruneTiles() {\n      if (this._map) {\n        var t,\n            i,\n            e = this._map.getZoom();\n\n        if (e > this.options.maxZoom || e < this.options.minZoom) this._removeAllTiles();else {\n          for (t in this._tiles) {\n            (i = this._tiles[t]).retain = i.current;\n          }\n\n          for (t in this._tiles) {\n            if ((i = this._tiles[t]).current && !i.active) {\n              var n = i.coords;\n              this._retainParent(n.x, n.y, n.z, n.z - 5) || this._retainChildren(n.x, n.y, n.z, n.z + 2);\n            }\n          }\n\n          for (t in this._tiles) {\n            this._tiles[t].retain || this._removeTile(t);\n          }\n        }\n      }\n    },\n    _removeTilesAtZoom: function _removeTilesAtZoom(t) {\n      for (var i in this._tiles) {\n        this._tiles[i].coords.z === t && this._removeTile(i);\n      }\n    },\n    _removeAllTiles: function _removeAllTiles() {\n      for (var t in this._tiles) {\n        this._removeTile(t);\n      }\n    },\n    _invalidateAll: function _invalidateAll() {\n      for (var t in this._levels) {\n        K(this._levels[t].el), this._onRemoveLevel(t), delete this._levels[t];\n      }\n\n      this._removeAllTiles(), this._tileZoom = void 0;\n    },\n    _retainParent: function _retainParent(t, i, e, n) {\n      var o = Math.floor(t / 2),\n          s = Math.floor(i / 2),\n          r = e - 1,\n          a = new x(+o, +s);\n      a.z = +r;\n\n      var h = this._tileCoordsToKey(a),\n          u = this._tiles[h];\n\n      return u && u.active ? (u.retain = !0, !0) : (u && u.loaded && (u.retain = !0), r > n && this._retainParent(o, s, r, n));\n    },\n    _retainChildren: function _retainChildren(t, i, e, n) {\n      for (var o = 2 * t; o < 2 * t + 2; o++) {\n        for (var s = 2 * i; s < 2 * i + 2; s++) {\n          var r = new x(o, s);\n          r.z = e + 1;\n\n          var a = this._tileCoordsToKey(r),\n              h = this._tiles[a];\n\n          h && h.active ? h.retain = !0 : (h && h.loaded && (h.retain = !0), e + 1 < n && this._retainChildren(o, s, e + 1, n));\n        }\n      }\n    },\n    _resetView: function _resetView(t) {\n      var i = t && (t.pinch || t.flyTo);\n\n      this._setView(this._map.getCenter(), this._map.getZoom(), i, i);\n    },\n    _animateZoom: function _animateZoom(t) {\n      this._setView(t.center, t.zoom, !0, t.noUpdate);\n    },\n    _clampZoom: function _clampZoom(t) {\n      var i = this.options;\n      return void 0 !== i.minNativeZoom && t < i.minNativeZoom ? i.minNativeZoom : void 0 !== i.maxNativeZoom && i.maxNativeZoom < t ? i.maxNativeZoom : t;\n    },\n    _setView: function _setView(t, i, e, n) {\n      var o = this._clampZoom(Math.round(i));\n\n      (void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom) && (o = void 0);\n      var s = this.options.updateWhenZooming && o !== this._tileZoom;\n      n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), e || this._pruneTiles(), this._noPrune = !!e), this._setZoomTransforms(t, i);\n    },\n    _setZoomTransforms: function _setZoomTransforms(t, i) {\n      for (var e in this._levels) {\n        this._setZoomTransform(this._levels[e], t, i);\n      }\n    },\n    _setZoomTransform: function _setZoomTransform(t, i, e) {\n      var n = this._map.getZoomScale(e, t.zoom),\n          o = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(i, e)).round();\n\n      ji ? rt(t.el, o, n) : at(t.el, o);\n    },\n    _resetGrid: function _resetGrid() {\n      var t = this._map,\n          i = t.options.crs,\n          e = this._tileSize = this.getTileSize(),\n          n = this._tileZoom,\n          o = this._map.getPixelWorldBounds(this._tileZoom);\n\n      o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = i.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, i.wrapLng[0]], n).x / e.x), Math.ceil(t.project([0, i.wrapLng[1]], n).x / e.y)], this._wrapY = i.wrapLat && !this.options.noWrap && [Math.floor(t.project([i.wrapLat[0], 0], n).y / e.x), Math.ceil(t.project([i.wrapLat[1], 0], n).y / e.y)];\n    },\n    _onMoveEnd: function _onMoveEnd() {\n      this._map && !this._map._animatingZoom && this._update();\n    },\n    _getTiledPixelBounds: function _getTiledPixelBounds(t) {\n      var i = this._map,\n          e = i._animatingZoom ? Math.max(i._animateToZoom, i.getZoom()) : i.getZoom(),\n          n = i.getZoomScale(e, this._tileZoom),\n          o = i.project(t, this._tileZoom).floor(),\n          s = i.getSize().divideBy(2 * n);\n      return new P(o.subtract(s), o.add(s));\n    },\n    _update: function _update(t) {\n      var i = this._map;\n\n      if (i) {\n        var e = this._clampZoom(i.getZoom());\n\n        if (void 0 === t && (t = i.getCenter()), void 0 !== this._tileZoom) {\n          var n = this._getTiledPixelBounds(t),\n              o = this._pxBoundsToTileRange(n),\n              s = o.getCenter(),\n              r = [],\n              a = this.options.keepBuffer,\n              h = new P(o.getBottomLeft().subtract([a, -a]), o.getTopRight().add([a, -a]));\n\n          if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error(\"Attempted to load an infinite number of tiles\");\n\n          for (var u in this._tiles) {\n            var l = this._tiles[u].coords;\n            l.z === this._tileZoom && h.contains(new x(l.x, l.y)) || (this._tiles[u].current = !1);\n          }\n\n          if (Math.abs(e - this._tileZoom) > 1) this._setView(t, e);else {\n            for (var c = o.min.y; c <= o.max.y; c++) {\n              for (var _ = o.min.x; _ <= o.max.x; _++) {\n                var d = new x(_, c);\n\n                if (d.z = this._tileZoom, this._isValidTile(d)) {\n                  var p = this._tiles[this._tileCoordsToKey(d)];\n\n                  p ? p.current = !0 : r.push(d);\n                }\n              }\n            }\n\n            if (r.sort(function (t, i) {\n              return t.distanceTo(s) - i.distanceTo(s);\n            }), 0 !== r.length) {\n              this._loading || (this._loading = !0, this.fire(\"loading\"));\n              var m = document.createDocumentFragment();\n\n              for (_ = 0; _ < r.length; _++) {\n                this._addTile(r[_], m);\n              }\n\n              this._level.el.appendChild(m);\n            }\n          }\n        }\n      }\n    },\n    _isValidTile: function _isValidTile(t) {\n      var i = this._map.options.crs;\n\n      if (!i.infinite) {\n        var e = this._globalTileRange;\n        if (!i.wrapLng && (t.x < e.min.x || t.x > e.max.x) || !i.wrapLat && (t.y < e.min.y || t.y > e.max.y)) return !1;\n      }\n\n      if (!this.options.bounds) return !0;\n\n      var n = this._tileCoordsToBounds(t);\n\n      return z(this.options.bounds).overlaps(n);\n    },\n    _keyToBounds: function _keyToBounds(t) {\n      return this._tileCoordsToBounds(this._keyToTileCoords(t));\n    },\n    _tileCoordsToNwSe: function _tileCoordsToNwSe(t) {\n      var i = this._map,\n          e = this.getTileSize(),\n          n = t.scaleBy(e),\n          o = n.add(e);\n      return [i.unproject(n, t.z), i.unproject(o, t.z)];\n    },\n    _tileCoordsToBounds: function _tileCoordsToBounds(t) {\n      var i = this._tileCoordsToNwSe(t),\n          e = new T(i[0], i[1]);\n\n      return this.options.noWrap || (e = this._map.wrapLatLngBounds(e)), e;\n    },\n    _tileCoordsToKey: function _tileCoordsToKey(t) {\n      return t.x + \":\" + t.y + \":\" + t.z;\n    },\n    _keyToTileCoords: function _keyToTileCoords(t) {\n      var i = t.split(\":\"),\n          e = new x(+i[0], +i[1]);\n      return e.z = +i[2], e;\n    },\n    _removeTile: function _removeTile(t) {\n      var i = this._tiles[t];\n      i && (K(i.el), delete this._tiles[t], this.fire(\"tileunload\", {\n        tile: i.el,\n        coords: this._keyToTileCoords(t)\n      }));\n    },\n    _initTile: function _initTile(t) {\n      Q(t, \"leaflet-tile\");\n      var i = this.getTileSize();\n      t.style.width = i.x + \"px\", t.style.height = i.y + \"px\", t.onselectstart = r, t.onmousemove = r, Li && this.options.opacity < 1 && nt(t, this.options.opacity), zi && !Mi && (t.style.WebkitBackfaceVisibility = \"hidden\");\n    },\n    _addTile: function _addTile(t, i) {\n      var n = this._getTilePos(t),\n          o = this._tileCoordsToKey(t),\n          s = this.createTile(this._wrapCoords(t), e(this._tileReady, this, t));\n\n      this._initTile(s), this.createTile.length < 2 && f(e(this._tileReady, this, t, null, s)), at(s, n), this._tiles[o] = {\n        el: s,\n        coords: t,\n        current: !0\n      }, i.appendChild(s), this.fire(\"tileloadstart\", {\n        tile: s,\n        coords: t\n      });\n    },\n    _tileReady: function _tileReady(t, i, n) {\n      i && this.fire(\"tileerror\", {\n        error: i,\n        tile: n,\n        coords: t\n      });\n\n      var o = this._tileCoordsToKey(t);\n\n      (n = this._tiles[o]) && (n.loaded = +new Date(), this._map._fadeAnimated ? (nt(n.el, 0), g(this._fadeFrame), this._fadeFrame = f(this._updateOpacity, this)) : (n.active = !0, this._pruneTiles()), i || (Q(n.el, \"leaflet-tile-loaded\"), this.fire(\"tileload\", {\n        tile: n.el,\n        coords: t\n      })), this._noTilesToLoad() && (this._loading = !1, this.fire(\"load\"), Li || !this._map._fadeAnimated ? f(this._pruneTiles, this) : setTimeout(e(this._pruneTiles, this), 250)));\n    },\n    _getTilePos: function _getTilePos(t) {\n      return t.scaleBy(this.getTileSize()).subtract(this._level.origin);\n    },\n    _wrapCoords: function _wrapCoords(t) {\n      var i = new x(this._wrapX ? s(t.x, this._wrapX) : t.x, this._wrapY ? s(t.y, this._wrapY) : t.y);\n      return i.z = t.z, i;\n    },\n    _pxBoundsToTileRange: function _pxBoundsToTileRange(t) {\n      var i = this.getTileSize();\n      return new P(t.min.unscaleBy(i).floor(), t.max.unscaleBy(i).ceil().subtract([1, 1]));\n    },\n    _noTilesToLoad: function _noTilesToLoad() {\n      for (var t in this._tiles) {\n        if (!this._tiles[t].loaded) return !1;\n      }\n\n      return !0;\n    }\n  }),\n      mn = pn.extend({\n    options: {\n      minZoom: 0,\n      maxZoom: 18,\n      subdomains: \"abc\",\n      errorTileUrl: \"\",\n      zoomOffset: 0,\n      tms: !1,\n      zoomReverse: !1,\n      detectRetina: !1,\n      crossOrigin: !1\n    },\n    initialize: function initialize(t, i) {\n      this._url = t, (i = l(this, i)).detectRetina && Yi && i.maxZoom > 0 && (i.tileSize = Math.floor(i.tileSize / 2), i.zoomReverse ? (i.zoomOffset--, i.minZoom++) : (i.zoomOffset++, i.maxZoom--), i.minZoom = Math.max(0, i.minZoom)), \"string\" == typeof i.subdomains && (i.subdomains = i.subdomains.split(\"\")), zi || this.on(\"tileunload\", this._onTileRemove);\n    },\n    setUrl: function setUrl(t, i) {\n      return this._url === t && void 0 === i && (i = !0), this._url = t, i || this.redraw(), this;\n    },\n    createTile: function createTile(t, i) {\n      var n = document.createElement(\"img\");\n      return mt(n, \"load\", e(this._tileOnLoad, this, i, n)), mt(n, \"error\", e(this._tileOnError, this, i, n)), (this.options.crossOrigin || \"\" === this.options.crossOrigin) && (n.crossOrigin = !0 === this.options.crossOrigin ? \"\" : this.options.crossOrigin), n.alt = \"\", n.setAttribute(\"role\", \"presentation\"), n.src = this.getTileUrl(t), n;\n    },\n    getTileUrl: function getTileUrl(t) {\n      var e = {\n        r: Yi ? \"@2x\" : \"\",\n        s: this._getSubdomain(t),\n        x: t.x,\n        y: t.y,\n        z: this._getZoomForUrl()\n      };\n\n      if (this._map && !this._map.options.crs.infinite) {\n        var n = this._globalTileRange.max.y - t.y;\n        this.options.tms && (e.y = n), e[\"-y\"] = n;\n      }\n\n      return _(this._url, i(e, this.options));\n    },\n    _tileOnLoad: function _tileOnLoad(t, i) {\n      Li ? setTimeout(e(t, this, null, i), 0) : t(null, i);\n    },\n    _tileOnError: function _tileOnError(t, i, e) {\n      var n = this.options.errorTileUrl;\n      n && i.getAttribute(\"src\") !== n && (i.src = n), t(e, i);\n    },\n    _onTileRemove: function _onTileRemove(t) {\n      t.tile.onload = null;\n    },\n    _getZoomForUrl: function _getZoomForUrl() {\n      var t = this._tileZoom,\n          i = this.options.maxZoom,\n          e = this.options.zoomReverse,\n          n = this.options.zoomOffset;\n      return e && (t = i - t), t + n;\n    },\n    _getSubdomain: function _getSubdomain(t) {\n      var i = Math.abs(t.x + t.y) % this.options.subdomains.length;\n      return this.options.subdomains[i];\n    },\n    _abortLoading: function _abortLoading() {\n      var t, i;\n\n      for (t in this._tiles) {\n        this._tiles[t].coords.z !== this._tileZoom && ((i = this._tiles[t].el).onload = r, i.onerror = r, i.complete || (i.src = si, K(i), delete this._tiles[t]));\n      }\n    },\n    _removeTile: function _removeTile(t) {\n      var i = this._tiles[t];\n      if (i) return Si || i.el.setAttribute(\"src\", si), pn.prototype._removeTile.call(this, t);\n    },\n    _tileReady: function _tileReady(t, i, e) {\n      if (this._map && (!e || e.getAttribute(\"src\") !== si)) return pn.prototype._tileReady.call(this, t, i, e);\n    }\n  }),\n      fn = mn.extend({\n    defaultWmsParams: {\n      service: \"WMS\",\n      request: \"GetMap\",\n      layers: \"\",\n      styles: \"\",\n      format: \"image/jpeg\",\n      transparent: !1,\n      version: \"1.1.1\"\n    },\n    options: {\n      crs: null,\n      uppercase: !1\n    },\n    initialize: function initialize(t, e) {\n      this._url = t;\n      var n = i({}, this.defaultWmsParams);\n\n      for (var o in e) {\n        o in this.options || (n[o] = e[o]);\n      }\n\n      var s = (e = l(this, e)).detectRetina && Yi ? 2 : 1,\n          r = this.getTileSize();\n      n.width = r.x * s, n.height = r.y * s, this.wmsParams = n;\n    },\n    onAdd: function onAdd(t) {\n      this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version);\n      var i = this._wmsVersion >= 1.3 ? \"crs\" : \"srs\";\n      this.wmsParams[i] = this._crs.code, mn.prototype.onAdd.call(this, t);\n    },\n    getTileUrl: function getTileUrl(t) {\n      var i = this._tileCoordsToNwSe(t),\n          e = this._crs,\n          n = b(e.project(i[0]), e.project(i[1])),\n          o = n.min,\n          s = n.max,\n          r = (this._wmsVersion >= 1.3 && this._crs === Ue ? [o.y, o.x, s.y, s.x] : [o.x, o.y, s.x, s.y]).join(\",\"),\n          a = mn.prototype.getTileUrl.call(this, t);\n\n      return a + c(this.wmsParams, a, this.options.uppercase) + (this.options.uppercase ? \"&BBOX=\" : \"&bbox=\") + r;\n    },\n    setParams: function setParams(t, e) {\n      return i(this.wmsParams, t), e || this.redraw(), this;\n    }\n  });\n  mn.WMS = fn, Jt.wms = function (t, i) {\n    return new fn(t, i);\n  };\n\n  var gn = qe.extend({\n    options: {\n      padding: .1,\n      tolerance: 0\n    },\n    initialize: function initialize(t) {\n      l(this, t), n(this), this._layers = this._layers || {};\n    },\n    onAdd: function onAdd() {\n      this._container || (this._initContainer(), this._zoomAnimated && Q(this._container, \"leaflet-zoom-animated\")), this.getPane().appendChild(this._container), this._update(), this.on(\"update\", this._updatePaths, this);\n    },\n    onRemove: function onRemove() {\n      this.off(\"update\", this._updatePaths, this), this._destroyContainer();\n    },\n    getEvents: function getEvents() {\n      var t = {\n        viewreset: this._reset,\n        zoom: this._onZoom,\n        moveend: this._update,\n        zoomend: this._onZoomEnd\n      };\n      return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t;\n    },\n    _onAnimZoom: function _onAnimZoom(t) {\n      this._updateTransform(t.center, t.zoom);\n    },\n    _onZoom: function _onZoom() {\n      this._updateTransform(this._map.getCenter(), this._map.getZoom());\n    },\n    _updateTransform: function _updateTransform(t, i) {\n      var e = this._map.getZoomScale(i, this._zoom),\n          n = ht(this._container),\n          o = this._map.getSize().multiplyBy(.5 + this.options.padding),\n          s = this._map.project(this._center, i),\n          r = this._map.project(t, i).subtract(s),\n          a = o.multiplyBy(-e).add(n).add(o).subtract(r);\n\n      ji ? rt(this._container, a, e) : at(this._container, a);\n    },\n    _reset: function _reset() {\n      this._update(), this._updateTransform(this._center, this._zoom);\n\n      for (var t in this._layers) {\n        this._layers[t]._reset();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      for (var t in this._layers) {\n        this._layers[t]._project();\n      }\n    },\n    _updatePaths: function _updatePaths() {\n      for (var t in this._layers) {\n        this._layers[t]._update();\n      }\n    },\n    _update: function _update() {\n      var t = this.options.padding,\n          i = this._map.getSize(),\n          e = this._map.containerPointToLayerPoint(i.multiplyBy(-t)).round();\n\n      this._bounds = new P(e, e.add(i.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom();\n    }\n  }),\n      vn = gn.extend({\n    getEvents: function getEvents() {\n      var t = gn.prototype.getEvents.call(this);\n      return t.viewprereset = this._onViewPreReset, t;\n    },\n    _onViewPreReset: function _onViewPreReset() {\n      this._postponeUpdatePaths = !0;\n    },\n    onAdd: function onAdd() {\n      gn.prototype.onAdd.call(this), this._draw();\n    },\n    _initContainer: function _initContainer() {\n      var t = this._container = document.createElement(\"canvas\");\n      mt(t, \"mousemove\", o(this._onMouseMove, 32, this), this), mt(t, \"click dblclick mousedown mouseup contextmenu\", this._onClick, this), mt(t, \"mouseout\", this._handleMouseOut, this), this._ctx = t.getContext(\"2d\");\n    },\n    _destroyContainer: function _destroyContainer() {\n      g(this._redrawRequest), delete this._ctx, K(this._container), ft(this._container), delete this._container;\n    },\n    _updatePaths: function _updatePaths() {\n      if (!this._postponeUpdatePaths) {\n        this._redrawBounds = null;\n\n        for (var t in this._layers) {\n          this._layers[t]._update();\n        }\n\n        this._redraw();\n      }\n    },\n    _update: function _update() {\n      if (!this._map._animatingZoom || !this._bounds) {\n        gn.prototype._update.call(this);\n\n        var t = this._bounds,\n            i = this._container,\n            e = t.getSize(),\n            n = Yi ? 2 : 1;\n        at(i, t.min), i.width = n * e.x, i.height = n * e.y, i.style.width = e.x + \"px\", i.style.height = e.y + \"px\", Yi && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire(\"update\");\n      }\n    },\n    _reset: function _reset() {\n      gn.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths());\n    },\n    _initPath: function _initPath(t) {\n      this._updateDashArray(t), this._layers[n(t)] = t;\n      var i = t._order = {\n        layer: t,\n        prev: this._drawLast,\n        next: null\n      };\n      this._drawLast && (this._drawLast.next = i), this._drawLast = i, this._drawFirst = this._drawFirst || this._drawLast;\n    },\n    _addPath: function _addPath(t) {\n      this._requestRedraw(t);\n    },\n    _removePath: function _removePath(t) {\n      var i = t._order,\n          e = i.next,\n          o = i.prev;\n      e ? e.prev = o : this._drawLast = o, o ? o.next = e : this._drawFirst = e, delete t._order, delete this._layers[n(t)], this._requestRedraw(t);\n    },\n    _updatePath: function _updatePath(t) {\n      this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t);\n    },\n    _updateStyle: function _updateStyle(t) {\n      this._updateDashArray(t), this._requestRedraw(t);\n    },\n    _updateDashArray: function _updateDashArray(t) {\n      if (\"string\" == typeof t.options.dashArray) {\n        var i,\n            e,\n            n = t.options.dashArray.split(/[, ]+/),\n            o = [];\n\n        for (e = 0; e < n.length; e++) {\n          if (i = Number(n[e]), isNaN(i)) return;\n          o.push(i);\n        }\n\n        t.options._dashArray = o;\n      } else t.options._dashArray = t.options.dashArray;\n    },\n    _requestRedraw: function _requestRedraw(t) {\n      this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || f(this._redraw, this));\n    },\n    _extendRedrawBounds: function _extendRedrawBounds(t) {\n      if (t._pxBounds) {\n        var i = (t.options.weight || 0) + 1;\n        this._redrawBounds = this._redrawBounds || new P(), this._redrawBounds.extend(t._pxBounds.min.subtract([i, i])), this._redrawBounds.extend(t._pxBounds.max.add([i, i]));\n      }\n    },\n    _redraw: function _redraw() {\n      this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null;\n    },\n    _clear: function _clear() {\n      var t = this._redrawBounds;\n\n      if (t) {\n        var i = t.getSize();\n\n        this._ctx.clearRect(t.min.x, t.min.y, i.x, i.y);\n      } else this._ctx.clearRect(0, 0, this._container.width, this._container.height);\n    },\n    _draw: function _draw() {\n      var t,\n          i = this._redrawBounds;\n\n      if (this._ctx.save(), i) {\n        var e = i.getSize();\n        this._ctx.beginPath(), this._ctx.rect(i.min.x, i.min.y, e.x, e.y), this._ctx.clip();\n      }\n\n      this._drawing = !0;\n\n      for (var n = this._drawFirst; n; n = n.next) {\n        t = n.layer, (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath();\n      }\n\n      this._drawing = !1, this._ctx.restore();\n    },\n    _updatePoly: function _updatePoly(t, i) {\n      if (this._drawing) {\n        var e,\n            n,\n            o,\n            s,\n            r = t._parts,\n            a = r.length,\n            h = this._ctx;\n\n        if (a) {\n          for (h.beginPath(), e = 0; e < a; e++) {\n            for (n = 0, o = r[e].length; n < o; n++) {\n              s = r[e][n], h[n ? \"lineTo\" : \"moveTo\"](s.x, s.y);\n            }\n\n            i && h.closePath();\n          }\n\n          this._fillStroke(h, t);\n        }\n      }\n    },\n    _updateCircle: function _updateCircle(t) {\n      if (this._drawing && !t._empty()) {\n        var i = t._point,\n            e = this._ctx,\n            n = Math.max(Math.round(t._radius), 1),\n            o = (Math.max(Math.round(t._radiusY), 1) || n) / n;\n        1 !== o && (e.save(), e.scale(1, o)), e.beginPath(), e.arc(i.x, i.y / o, n, 0, 2 * Math.PI, !1), 1 !== o && e.restore(), this._fillStroke(e, t);\n      }\n    },\n    _fillStroke: function _fillStroke(t, i) {\n      var e = i.options;\n      e.fill && (t.globalAlpha = e.fillOpacity, t.fillStyle = e.fillColor || e.color, t.fill(e.fillRule || \"evenodd\")), e.stroke && 0 !== e.weight && (t.setLineDash && t.setLineDash(i.options && i.options._dashArray || []), t.globalAlpha = e.opacity, t.lineWidth = e.weight, t.strokeStyle = e.color, t.lineCap = e.lineCap, t.lineJoin = e.lineJoin, t.stroke());\n    },\n    _onClick: function _onClick(t) {\n      for (var i, e, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next) {\n        (i = o.layer).options.interactive && i._containsPoint(n) && !this._map._draggableMoved(i) && (e = i);\n      }\n\n      e && (zt(t), this._fireEvent([e], t));\n    },\n    _onMouseMove: function _onMouseMove(t) {\n      if (this._map && !this._map.dragging.moving() && !this._map._animatingZoom) {\n        var i = this._map.mouseEventToLayerPoint(t);\n\n        this._handleMouseHover(t, i);\n      }\n    },\n    _handleMouseOut: function _handleMouseOut(t) {\n      var i = this._hoveredLayer;\n      i && (tt(this._container, \"leaflet-interactive\"), this._fireEvent([i], t, \"mouseout\"), this._hoveredLayer = null);\n    },\n    _handleMouseHover: function _handleMouseHover(t, i) {\n      for (var e, n, o = this._drawFirst; o; o = o.next) {\n        (e = o.layer).options.interactive && e._containsPoint(i) && (n = e);\n      }\n\n      n !== this._hoveredLayer && (this._handleMouseOut(t), n && (Q(this._container, \"leaflet-interactive\"), this._fireEvent([n], t, \"mouseover\"), this._hoveredLayer = n)), this._hoveredLayer && this._fireEvent([this._hoveredLayer], t);\n    },\n    _fireEvent: function _fireEvent(t, i, e) {\n      this._map._fireDOMEvent(i, e || i.type, t);\n    },\n    _bringToFront: function _bringToFront(t) {\n      var i = t._order;\n\n      if (i) {\n        var e = i.next,\n            n = i.prev;\n        e && (e.prev = n, n ? n.next = e : e && (this._drawFirst = e), i.prev = this._drawLast, this._drawLast.next = i, i.next = null, this._drawLast = i, this._requestRedraw(t));\n      }\n    },\n    _bringToBack: function _bringToBack(t) {\n      var i = t._order;\n\n      if (i) {\n        var e = i.next,\n            n = i.prev;\n        n && (n.next = e, e ? e.prev = n : n && (this._drawLast = n), i.prev = null, i.next = this._drawFirst, this._drawFirst.prev = i, this._drawFirst = i, this._requestRedraw(t));\n      }\n    }\n  }),\n      yn = function () {\n    try {\n      return document.namespaces.add(\"lvml\", \"urn:schemas-microsoft-com:vml\"), function (t) {\n        return document.createElement(\"<lvml:\" + t + ' class=\"lvml\">');\n      };\n    } catch (t) {\n      return function (t) {\n        return document.createElement(\"<\" + t + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"lvml\">');\n      };\n    }\n  }(),\n      xn = {\n    _initContainer: function _initContainer() {\n      this._container = G(\"div\", \"leaflet-vml-container\");\n    },\n    _update: function _update() {\n      this._map._animatingZoom || (gn.prototype._update.call(this), this.fire(\"update\"));\n    },\n    _initPath: function _initPath(t) {\n      var i = t._container = yn(\"shape\");\n      Q(i, \"leaflet-vml-shape \" + (this.options.className || \"\")), i.coordsize = \"1 1\", t._path = yn(\"path\"), i.appendChild(t._path), this._updateStyle(t), this._layers[n(t)] = t;\n    },\n    _addPath: function _addPath(t) {\n      var i = t._container;\n      this._container.appendChild(i), t.options.interactive && t.addInteractiveTarget(i);\n    },\n    _removePath: function _removePath(t) {\n      var i = t._container;\n      K(i), t.removeInteractiveTarget(i), delete this._layers[n(t)];\n    },\n    _updateStyle: function _updateStyle(t) {\n      var i = t._stroke,\n          e = t._fill,\n          n = t.options,\n          o = t._container;\n      o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (i || (i = t._stroke = yn(\"stroke\")), o.appendChild(i), i.weight = n.weight + \"px\", i.color = n.color, i.opacity = n.opacity, n.dashArray ? i.dashStyle = oi(n.dashArray) ? n.dashArray.join(\" \") : n.dashArray.replace(/( *, *)/g, \" \") : i.dashStyle = \"\", i.endcap = n.lineCap.replace(\"butt\", \"flat\"), i.joinstyle = n.lineJoin) : i && (o.removeChild(i), t._stroke = null), n.fill ? (e || (e = t._fill = yn(\"fill\")), o.appendChild(e), e.color = n.fillColor || n.color, e.opacity = n.fillOpacity) : e && (o.removeChild(e), t._fill = null);\n    },\n    _updateCircle: function _updateCircle(t) {\n      var i = t._point.round(),\n          e = Math.round(t._radius),\n          n = Math.round(t._radiusY || e);\n\n      this._setPath(t, t._empty() ? \"M0 0\" : \"AL \" + i.x + \",\" + i.y + \" \" + e + \",\" + n + \" 0,23592600\");\n    },\n    _setPath: function _setPath(t, i) {\n      t._path.v = i;\n    },\n    _bringToFront: function _bringToFront(t) {\n      X(t._container);\n    },\n    _bringToBack: function _bringToBack(t) {\n      J(t._container);\n    }\n  },\n      wn = $i ? yn : E,\n      Pn = gn.extend({\n    getEvents: function getEvents() {\n      var t = gn.prototype.getEvents.call(this);\n      return t.zoomstart = this._onZoomStart, t;\n    },\n    _initContainer: function _initContainer() {\n      this._container = wn(\"svg\"), this._container.setAttribute(\"pointer-events\", \"none\"), this._rootGroup = wn(\"g\"), this._container.appendChild(this._rootGroup);\n    },\n    _destroyContainer: function _destroyContainer() {\n      K(this._container), ft(this._container), delete this._container, delete this._rootGroup, delete this._svgSize;\n    },\n    _onZoomStart: function _onZoomStart() {\n      this._update();\n    },\n    _update: function _update() {\n      if (!this._map._animatingZoom || !this._bounds) {\n        gn.prototype._update.call(this);\n\n        var t = this._bounds,\n            i = t.getSize(),\n            e = this._container;\n        this._svgSize && this._svgSize.equals(i) || (this._svgSize = i, e.setAttribute(\"width\", i.x), e.setAttribute(\"height\", i.y)), at(e, t.min), e.setAttribute(\"viewBox\", [t.min.x, t.min.y, i.x, i.y].join(\" \")), this.fire(\"update\");\n      }\n    },\n    _initPath: function _initPath(t) {\n      var i = t._path = wn(\"path\");\n      t.options.className && Q(i, t.options.className), t.options.interactive && Q(i, \"leaflet-interactive\"), this._updateStyle(t), this._layers[n(t)] = t;\n    },\n    _addPath: function _addPath(t) {\n      this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path);\n    },\n    _removePath: function _removePath(t) {\n      K(t._path), t.removeInteractiveTarget(t._path), delete this._layers[n(t)];\n    },\n    _updatePath: function _updatePath(t) {\n      t._project(), t._update();\n    },\n    _updateStyle: function _updateStyle(t) {\n      var i = t._path,\n          e = t.options;\n      i && (e.stroke ? (i.setAttribute(\"stroke\", e.color), i.setAttribute(\"stroke-opacity\", e.opacity), i.setAttribute(\"stroke-width\", e.weight), i.setAttribute(\"stroke-linecap\", e.lineCap), i.setAttribute(\"stroke-linejoin\", e.lineJoin), e.dashArray ? i.setAttribute(\"stroke-dasharray\", e.dashArray) : i.removeAttribute(\"stroke-dasharray\"), e.dashOffset ? i.setAttribute(\"stroke-dashoffset\", e.dashOffset) : i.removeAttribute(\"stroke-dashoffset\")) : i.setAttribute(\"stroke\", \"none\"), e.fill ? (i.setAttribute(\"fill\", e.fillColor || e.color), i.setAttribute(\"fill-opacity\", e.fillOpacity), i.setAttribute(\"fill-rule\", e.fillRule || \"evenodd\")) : i.setAttribute(\"fill\", \"none\"));\n    },\n    _updatePoly: function _updatePoly(t, i) {\n      this._setPath(t, k(t._parts, i));\n    },\n    _updateCircle: function _updateCircle(t) {\n      var i = t._point,\n          e = Math.max(Math.round(t._radius), 1),\n          n = \"a\" + e + \",\" + (Math.max(Math.round(t._radiusY), 1) || e) + \" 0 1,0 \",\n          o = t._empty() ? \"M0 0\" : \"M\" + (i.x - e) + \",\" + i.y + n + 2 * e + \",0 \" + n + 2 * -e + \",0 \";\n\n      this._setPath(t, o);\n    },\n    _setPath: function _setPath(t, i) {\n      t._path.setAttribute(\"d\", i);\n    },\n    _bringToFront: function _bringToFront(t) {\n      X(t._path);\n    },\n    _bringToBack: function _bringToBack(t) {\n      J(t._path);\n    }\n  });\n\n  $i && Pn.include(xn), be.include({\n    getRenderer: function getRenderer(t) {\n      var i = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;\n\n      return i || (i = this._renderer = this._createRenderer()), this.hasLayer(i) || this.addLayer(i), i;\n    },\n    _getPaneRenderer: function _getPaneRenderer(t) {\n      if (\"overlayPane\" === t || void 0 === t) return !1;\n      var i = this._paneRenderers[t];\n      return void 0 === i && (i = this._createRenderer({\n        pane: t\n      }), this._paneRenderers[t] = i), i;\n    },\n    _createRenderer: function _createRenderer(t) {\n      return this.options.preferCanvas && $t(t) || Qt(t);\n    }\n  });\n  var Ln = on.extend({\n    initialize: function initialize(t, i) {\n      on.prototype.initialize.call(this, this._boundsToLatLngs(t), i);\n    },\n    setBounds: function setBounds(t) {\n      return this.setLatLngs(this._boundsToLatLngs(t));\n    },\n    _boundsToLatLngs: function _boundsToLatLngs(t) {\n      return t = z(t), [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()];\n    }\n  });\n  Pn.create = wn, Pn.pointsToPath = k, sn.geometryToLayer = Ft, sn.coordsToLatLng = Ut, sn.coordsToLatLngs = Vt, sn.latLngToCoords = qt, sn.latLngsToCoords = Gt, sn.getFeature = Kt, sn.asFeature = Yt, be.mergeOptions({\n    boxZoom: !0\n  });\n  var bn = Ee.extend({\n    initialize: function initialize(t) {\n      this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on(\"unload\", this._destroy, this);\n    },\n    addHooks: function addHooks() {\n      mt(this._container, \"mousedown\", this._onMouseDown, this);\n    },\n    removeHooks: function removeHooks() {\n      ft(this._container, \"mousedown\", this._onMouseDown, this);\n    },\n    moved: function moved() {\n      return this._moved;\n    },\n    _destroy: function _destroy() {\n      K(this._pane), delete this._pane;\n    },\n    _resetState: function _resetState() {\n      this._resetStateTimeout = 0, this._moved = !1;\n    },\n    _clearDeferredResetState: function _clearDeferredResetState() {\n      0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0);\n    },\n    _onMouseDown: function _onMouseDown(t) {\n      if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1;\n      this._clearDeferredResetState(), this._resetState(), fi(), ut(), this._startPoint = this._map.mouseEventToContainerPoint(t), mt(document, {\n        contextmenu: Lt,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseMove: function _onMouseMove(t) {\n      this._moved || (this._moved = !0, this._box = G(\"div\", \"leaflet-zoom-box\", this._container), Q(this._container, \"leaflet-crosshair\"), this._map.fire(\"boxzoomstart\")), this._point = this._map.mouseEventToContainerPoint(t);\n      var i = new P(this._point, this._startPoint),\n          e = i.getSize();\n      at(this._box, i.min), this._box.style.width = e.x + \"px\", this._box.style.height = e.y + \"px\";\n    },\n    _finish: function _finish() {\n      this._moved && (K(this._box), tt(this._container, \"leaflet-crosshair\")), gi(), lt(), ft(document, {\n        contextmenu: Lt,\n        mousemove: this._onMouseMove,\n        mouseup: this._onMouseUp,\n        keydown: this._onKeyDown\n      }, this);\n    },\n    _onMouseUp: function _onMouseUp(t) {\n      if ((1 === t.which || 1 === t.button) && (this._finish(), this._moved)) {\n        this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(e(this._resetState, this), 0);\n        var i = new T(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point));\n\n        this._map.fitBounds(i).fire(\"boxzoomend\", {\n          boxZoomBounds: i\n        });\n      }\n    },\n    _onKeyDown: function _onKeyDown(t) {\n      27 === t.keyCode && this._finish();\n    }\n  });\n  be.addInitHook(\"addHandler\", \"boxZoom\", bn), be.mergeOptions({\n    doubleClickZoom: !0\n  });\n  var Tn = Ee.extend({\n    addHooks: function addHooks() {\n      this._map.on(\"dblclick\", this._onDoubleClick, this);\n    },\n    removeHooks: function removeHooks() {\n      this._map.off(\"dblclick\", this._onDoubleClick, this);\n    },\n    _onDoubleClick: function _onDoubleClick(t) {\n      var i = this._map,\n          e = i.getZoom(),\n          n = i.options.zoomDelta,\n          o = t.originalEvent.shiftKey ? e - n : e + n;\n      \"center\" === i.options.doubleClickZoom ? i.setZoom(o) : i.setZoomAround(t.containerPoint, o);\n    }\n  });\n  be.addInitHook(\"addHandler\", \"doubleClickZoom\", Tn), be.mergeOptions({\n    dragging: !0,\n    inertia: !Mi,\n    inertiaDeceleration: 3400,\n    inertiaMaxSpeed: 1 / 0,\n    easeLinearity: .2,\n    worldCopyJump: !1,\n    maxBoundsViscosity: 0\n  });\n  var zn = Ee.extend({\n    addHooks: function addHooks() {\n      if (!this._draggable) {\n        var t = this._map;\n        this._draggable = new Re(t._mapPane, t._container), this._draggable.on({\n          dragstart: this._onDragStart,\n          drag: this._onDrag,\n          dragend: this._onDragEnd\n        }, this), this._draggable.on(\"predrag\", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on(\"predrag\", this._onPreDragWrap, this), t.on(\"zoomend\", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this));\n      }\n\n      Q(this._map._container, \"leaflet-grab leaflet-touch-drag\"), this._draggable.enable(), this._positions = [], this._times = [];\n    },\n    removeHooks: function removeHooks() {\n      tt(this._map._container, \"leaflet-grab\"), tt(this._map._container, \"leaflet-touch-drag\"), this._draggable.disable();\n    },\n    moved: function moved() {\n      return this._draggable && this._draggable._moved;\n    },\n    moving: function moving() {\n      return this._draggable && this._draggable._moving;\n    },\n    _onDragStart: function _onDragStart() {\n      var t = this._map;\n\n      if (t._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {\n        var i = z(this._map.options.maxBounds);\n        this._offsetLimit = b(this._map.latLngToContainerPoint(i.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(i.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity));\n      } else this._offsetLimit = null;\n\n      t.fire(\"movestart\").fire(\"dragstart\"), t.options.inertia && (this._positions = [], this._times = []);\n    },\n    _onDrag: function _onDrag(t) {\n      if (this._map.options.inertia) {\n        var i = this._lastTime = +new Date(),\n            e = this._lastPos = this._draggable._absPos || this._draggable._newPos;\n        this._positions.push(e), this._times.push(i), this._prunePositions(i);\n      }\n\n      this._map.fire(\"move\", t).fire(\"drag\", t);\n    },\n    _prunePositions: function _prunePositions(t) {\n      for (; this._positions.length > 1 && t - this._times[0] > 50;) {\n        this._positions.shift(), this._times.shift();\n      }\n    },\n    _onZoomEnd: function _onZoomEnd() {\n      var t = this._map.getSize().divideBy(2),\n          i = this._map.latLngToLayerPoint([0, 0]);\n\n      this._initialWorldOffset = i.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x;\n    },\n    _viscousLimit: function _viscousLimit(t, i) {\n      return t - (t - i) * this._viscosity;\n    },\n    _onPreDragLimit: function _onPreDragLimit() {\n      if (this._viscosity && this._offsetLimit) {\n        var t = this._draggable._newPos.subtract(this._draggable._startPos),\n            i = this._offsetLimit;\n\n        t.x < i.min.x && (t.x = this._viscousLimit(t.x, i.min.x)), t.y < i.min.y && (t.y = this._viscousLimit(t.y, i.min.y)), t.x > i.max.x && (t.x = this._viscousLimit(t.x, i.max.x)), t.y > i.max.y && (t.y = this._viscousLimit(t.y, i.max.y)), this._draggable._newPos = this._draggable._startPos.add(t);\n      }\n    },\n    _onPreDragWrap: function _onPreDragWrap() {\n      var t = this._worldWidth,\n          i = Math.round(t / 2),\n          e = this._initialWorldOffset,\n          n = this._draggable._newPos.x,\n          o = (n - i + e) % t + i - e,\n          s = (n + i + e) % t - i - e,\n          r = Math.abs(o + e) < Math.abs(s + e) ? o : s;\n      this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = r;\n    },\n    _onDragEnd: function _onDragEnd(t) {\n      var i = this._map,\n          e = i.options,\n          n = !e.inertia || this._times.length < 2;\n      if (i.fire(\"dragend\", t), n) i.fire(\"moveend\");else {\n        this._prunePositions(+new Date());\n\n        var o = this._lastPos.subtract(this._positions[0]),\n            s = (this._lastTime - this._times[0]) / 1e3,\n            r = e.easeLinearity,\n            a = o.multiplyBy(r / s),\n            h = a.distanceTo([0, 0]),\n            u = Math.min(e.inertiaMaxSpeed, h),\n            l = a.multiplyBy(u / h),\n            c = u / (e.inertiaDeceleration * r),\n            _ = l.multiplyBy(-c / 2).round();\n\n        _.x || _.y ? (_ = i._limitOffset(_, i.options.maxBounds), f(function () {\n          i.panBy(_, {\n            duration: c,\n            easeLinearity: r,\n            noMoveStart: !0,\n            animate: !0\n          });\n        })) : i.fire(\"moveend\");\n      }\n    }\n  });\n  be.addInitHook(\"addHandler\", \"dragging\", zn), be.mergeOptions({\n    keyboard: !0,\n    keyboardPanDelta: 80\n  });\n  var Mn = Ee.extend({\n    keyCodes: {\n      left: [37],\n      right: [39],\n      down: [40],\n      up: [38],\n      zoomIn: [187, 107, 61, 171],\n      zoomOut: [189, 109, 54, 173]\n    },\n    initialize: function initialize(t) {\n      this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta);\n    },\n    addHooks: function addHooks() {\n      var t = this._map._container;\n      t.tabIndex <= 0 && (t.tabIndex = \"0\"), mt(t, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this), this._map.on({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    removeHooks: function removeHooks() {\n      this._removeHooks(), ft(this._map._container, {\n        focus: this._onFocus,\n        blur: this._onBlur,\n        mousedown: this._onMouseDown\n      }, this), this._map.off({\n        focus: this._addHooks,\n        blur: this._removeHooks\n      }, this);\n    },\n    _onMouseDown: function _onMouseDown() {\n      if (!this._focused) {\n        var t = document.body,\n            i = document.documentElement,\n            e = t.scrollTop || i.scrollTop,\n            n = t.scrollLeft || i.scrollLeft;\n        this._map._container.focus(), window.scrollTo(n, e);\n      }\n    },\n    _onFocus: function _onFocus() {\n      this._focused = !0, this._map.fire(\"focus\");\n    },\n    _onBlur: function _onBlur() {\n      this._focused = !1, this._map.fire(\"blur\");\n    },\n    _setPanDelta: function _setPanDelta(t) {\n      var i,\n          e,\n          n = this._panKeys = {},\n          o = this.keyCodes;\n\n      for (i = 0, e = o.left.length; i < e; i++) {\n        n[o.left[i]] = [-1 * t, 0];\n      }\n\n      for (i = 0, e = o.right.length; i < e; i++) {\n        n[o.right[i]] = [t, 0];\n      }\n\n      for (i = 0, e = o.down.length; i < e; i++) {\n        n[o.down[i]] = [0, t];\n      }\n\n      for (i = 0, e = o.up.length; i < e; i++) {\n        n[o.up[i]] = [0, -1 * t];\n      }\n    },\n    _setZoomDelta: function _setZoomDelta(t) {\n      var i,\n          e,\n          n = this._zoomKeys = {},\n          o = this.keyCodes;\n\n      for (i = 0, e = o.zoomIn.length; i < e; i++) {\n        n[o.zoomIn[i]] = t;\n      }\n\n      for (i = 0, e = o.zoomOut.length; i < e; i++) {\n        n[o.zoomOut[i]] = -t;\n      }\n    },\n    _addHooks: function _addHooks() {\n      mt(document, \"keydown\", this._onKeyDown, this);\n    },\n    _removeHooks: function _removeHooks() {\n      ft(document, \"keydown\", this._onKeyDown, this);\n    },\n    _onKeyDown: function _onKeyDown(t) {\n      if (!(t.altKey || t.ctrlKey || t.metaKey)) {\n        var i,\n            e = t.keyCode,\n            n = this._map;\n        if (e in this._panKeys) n._panAnim && n._panAnim._inProgress || (i = this._panKeys[e], t.shiftKey && (i = w(i).multiplyBy(3)), n.panBy(i), n.options.maxBounds && n.panInsideBounds(n.options.maxBounds));else if (e in this._zoomKeys) n.setZoom(n.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[e]);else {\n          if (27 !== e || !n._popup || !n._popup.options.closeOnEscapeKey) return;\n          n.closePopup();\n        }\n        Lt(t);\n      }\n    }\n  });\n  be.addInitHook(\"addHandler\", \"keyboard\", Mn), be.mergeOptions({\n    scrollWheelZoom: !0,\n    wheelDebounceTime: 40,\n    wheelPxPerZoomLevel: 60\n  });\n  var Cn = Ee.extend({\n    addHooks: function addHooks() {\n      mt(this._map._container, \"mousewheel\", this._onWheelScroll, this), this._delta = 0;\n    },\n    removeHooks: function removeHooks() {\n      ft(this._map._container, \"mousewheel\", this._onWheelScroll, this);\n    },\n    _onWheelScroll: function _onWheelScroll(t) {\n      var i = Tt(t),\n          n = this._map.options.wheelDebounceTime;\n      this._delta += i, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date());\n      var o = Math.max(n - (+new Date() - this._startTime), 0);\n      clearTimeout(this._timer), this._timer = setTimeout(e(this._performZoom, this), o), Lt(t);\n    },\n    _performZoom: function _performZoom() {\n      var t = this._map,\n          i = t.getZoom(),\n          e = this._map.options.zoomSnap || 0;\n\n      t._stop();\n\n      var n = this._delta / (4 * this._map.options.wheelPxPerZoomLevel),\n          o = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2,\n          s = e ? Math.ceil(o / e) * e : o,\n          r = t._limitZoom(i + (this._delta > 0 ? s : -s)) - i;\n      this._delta = 0, this._startTime = null, r && (\"center\" === t.options.scrollWheelZoom ? t.setZoom(i + r) : t.setZoomAround(this._lastMousePos, i + r));\n    }\n  });\n  be.addInitHook(\"addHandler\", \"scrollWheelZoom\", Cn), be.mergeOptions({\n    tap: !0,\n    tapTolerance: 15\n  });\n  var Sn = Ee.extend({\n    addHooks: function addHooks() {\n      mt(this._map._container, \"touchstart\", this._onDown, this);\n    },\n    removeHooks: function removeHooks() {\n      ft(this._map._container, \"touchstart\", this._onDown, this);\n    },\n    _onDown: function _onDown(t) {\n      if (t.touches) {\n        if (Pt(t), this._fireClick = !0, t.touches.length > 1) return this._fireClick = !1, void clearTimeout(this._holdTimeout);\n        var i = t.touches[0],\n            n = i.target;\n        this._startPos = this._newPos = new x(i.clientX, i.clientY), n.tagName && \"a\" === n.tagName.toLowerCase() && Q(n, \"leaflet-active\"), this._holdTimeout = setTimeout(e(function () {\n          this._isTapValid() && (this._fireClick = !1, this._onUp(), this._simulateEvent(\"contextmenu\", i));\n        }, this), 1e3), this._simulateEvent(\"mousedown\", i), mt(document, {\n          touchmove: this._onMove,\n          touchend: this._onUp\n        }, this);\n      }\n    },\n    _onUp: function _onUp(t) {\n      if (clearTimeout(this._holdTimeout), ft(document, {\n        touchmove: this._onMove,\n        touchend: this._onUp\n      }, this), this._fireClick && t && t.changedTouches) {\n        var i = t.changedTouches[0],\n            e = i.target;\n        e && e.tagName && \"a\" === e.tagName.toLowerCase() && tt(e, \"leaflet-active\"), this._simulateEvent(\"mouseup\", i), this._isTapValid() && this._simulateEvent(\"click\", i);\n      }\n    },\n    _isTapValid: function _isTapValid() {\n      return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;\n    },\n    _onMove: function _onMove(t) {\n      var i = t.touches[0];\n      this._newPos = new x(i.clientX, i.clientY), this._simulateEvent(\"mousemove\", i);\n    },\n    _simulateEvent: function _simulateEvent(t, i) {\n      var e = document.createEvent(\"MouseEvents\");\n      e._simulated = !0, i.target._simulatedClick = !0, e.initMouseEvent(t, !0, !0, window, 1, i.screenX, i.screenY, i.clientX, i.clientY, !1, !1, !1, !1, 0, null), i.target.dispatchEvent(e);\n    }\n  });\n  qi && !Vi && be.addInitHook(\"addHandler\", \"tap\", Sn), be.mergeOptions({\n    touchZoom: qi && !Mi,\n    bounceAtZoomLimits: !0\n  });\n  var Zn = Ee.extend({\n    addHooks: function addHooks() {\n      Q(this._map._container, \"leaflet-touch-zoom\"), mt(this._map._container, \"touchstart\", this._onTouchStart, this);\n    },\n    removeHooks: function removeHooks() {\n      tt(this._map._container, \"leaflet-touch-zoom\"), ft(this._map._container, \"touchstart\", this._onTouchStart, this);\n    },\n    _onTouchStart: function _onTouchStart(t) {\n      var i = this._map;\n\n      if (t.touches && 2 === t.touches.length && !i._animatingZoom && !this._zooming) {\n        var e = i.mouseEventToContainerPoint(t.touches[0]),\n            n = i.mouseEventToContainerPoint(t.touches[1]);\n        this._centerPoint = i.getSize()._divideBy(2), this._startLatLng = i.containerPointToLatLng(this._centerPoint), \"center\" !== i.options.touchZoom && (this._pinchStartLatLng = i.containerPointToLatLng(e.add(n)._divideBy(2))), this._startDist = e.distanceTo(n), this._startZoom = i.getZoom(), this._moved = !1, this._zooming = !0, i._stop(), mt(document, \"touchmove\", this._onTouchMove, this), mt(document, \"touchend\", this._onTouchEnd, this), Pt(t);\n      }\n    },\n    _onTouchMove: function _onTouchMove(t) {\n      if (t.touches && 2 === t.touches.length && this._zooming) {\n        var i = this._map,\n            n = i.mouseEventToContainerPoint(t.touches[0]),\n            o = i.mouseEventToContainerPoint(t.touches[1]),\n            s = n.distanceTo(o) / this._startDist;\n\n        if (this._zoom = i.getScaleZoom(s, this._startZoom), !i.options.bounceAtZoomLimits && (this._zoom < i.getMinZoom() && s < 1 || this._zoom > i.getMaxZoom() && s > 1) && (this._zoom = i._limitZoom(this._zoom)), \"center\" === i.options.touchZoom) {\n          if (this._center = this._startLatLng, 1 === s) return;\n        } else {\n          var r = n._add(o)._divideBy(2)._subtract(this._centerPoint);\n\n          if (1 === s && 0 === r.x && 0 === r.y) return;\n          this._center = i.unproject(i.project(this._pinchStartLatLng, this._zoom).subtract(r), this._zoom);\n        }\n\n        this._moved || (i._moveStart(!0, !1), this._moved = !0), g(this._animRequest);\n        var a = e(i._move, i, this._center, this._zoom, {\n          pinch: !0,\n          round: !1\n        });\n        this._animRequest = f(a, this, !0), Pt(t);\n      }\n    },\n    _onTouchEnd: function _onTouchEnd() {\n      this._moved && this._zooming ? (this._zooming = !1, g(this._animRequest), ft(document, \"touchmove\", this._onTouchMove), ft(document, \"touchend\", this._onTouchEnd), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1;\n    }\n  });\n  be.addInitHook(\"addHandler\", \"touchZoom\", Zn), be.BoxZoom = bn, be.DoubleClickZoom = Tn, be.Drag = zn, be.Keyboard = Mn, be.ScrollWheelZoom = Cn, be.Tap = Sn, be.TouchZoom = Zn, Object.freeze = ti, t.version = \"1.4.0\", t.Control = Te, t.control = ze, t.Browser = Qi, t.Evented = ci, t.Mixin = Be, t.Util = ui, t.Class = v, t.Handler = Ee, t.extend = i, t.bind = e, t.stamp = n, t.setOptions = l, t.DomEvent = Pe, t.DomUtil = ve, t.PosAnimation = Le, t.Draggable = Re, t.LineUtil = Ne, t.PolyUtil = De, t.Point = x, t.point = w, t.Bounds = P, t.bounds = b, t.Transformation = S, t.transformation = Z, t.Projection = He, t.LatLng = M, t.latLng = C, t.LatLngBounds = T, t.latLngBounds = z, t.CRS = di, t.GeoJSON = sn, t.geoJSON = Xt, t.geoJson = an, t.Layer = qe, t.LayerGroup = Ge, t.layerGroup = function (t, i) {\n    return new Ge(t, i);\n  }, t.FeatureGroup = Ke, t.featureGroup = function (t) {\n    return new Ke(t);\n  }, t.ImageOverlay = hn, t.imageOverlay = function (t, i, e) {\n    return new hn(t, i, e);\n  }, t.VideoOverlay = un, t.videoOverlay = function (t, i, e) {\n    return new un(t, i, e);\n  }, t.DivOverlay = ln, t.Popup = cn, t.popup = function (t, i) {\n    return new cn(t, i);\n  }, t.Tooltip = _n, t.tooltip = function (t, i) {\n    return new _n(t, i);\n  }, t.Icon = Ye, t.icon = function (t) {\n    return new Ye(t);\n  }, t.DivIcon = dn, t.divIcon = function (t) {\n    return new dn(t);\n  }, t.Marker = $e, t.marker = function (t, i) {\n    return new $e(t, i);\n  }, t.TileLayer = mn, t.tileLayer = Jt, t.GridLayer = pn, t.gridLayer = function (t) {\n    return new pn(t);\n  }, t.SVG = Pn, t.svg = Qt, t.Renderer = gn, t.Canvas = vn, t.canvas = $t, t.Path = Qe, t.CircleMarker = tn, t.circleMarker = function (t, i) {\n    return new tn(t, i);\n  }, t.Circle = en, t.circle = function (t, i, e) {\n    return new en(t, i, e);\n  }, t.Polyline = nn, t.polyline = function (t, i) {\n    return new nn(t, i);\n  }, t.Polygon = on, t.polygon = function (t, i) {\n    return new on(t, i);\n  }, t.Rectangle = Ln, t.rectangle = function (t, i) {\n    return new Ln(t, i);\n  }, t.Map = be, t.map = function (t, i) {\n    return new be(t, i);\n  };\n  var En = window.L;\n  t.noConflict = function () {\n    return window.L = En, this;\n  }, window.L = t;\n});","map":null,"metadata":{},"sourceType":"script"}